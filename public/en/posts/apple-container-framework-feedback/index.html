<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How We Experimented with Apple's Container Framework | JCNM</title>
<meta name=keywords content="Apple Container,Containerization,Docker alternative,macOS containers,Apple Silicon development,Lightweight VMs,OCI,macOS virtualization"><meta name=description content="Discover our first experience with Apple's Container framework, a native containerization solution optimized for macOS and Apple Silicon, announced just a few days ago."><meta name=author content="Services CEO DevOps Team"><link rel=canonical href=https://sylorion.com/jcnm/en/posts/apple-container-framework-feedback/><meta name=google-site-verification content="G-T88E0SY453"><link crossorigin=anonymous href=/jcnm/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://sylorion.com/jcnm/images/icon32x32.png><link rel=icon type=image/png sizes=16x16 href=https://sylorion.com/jcnm/images/icon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sylorion.com/jcnm/images/icon32x32.png><link rel=apple-touch-icon href=https://sylorion.com/jcnm/images/icon152x152.png><link rel=mask-icon href=https://sylorion.com/jcnm/images/icon180x180.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sylorion.com/jcnm/en/posts/apple-container-framework-feedback/><link rel=alternate hreflang=fr href=https://sylorion.com/jcnm/posts/apple-container-framework-tests-et-retours/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-T88E0SY453"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-T88E0SY453")</script><meta property="og:url" content="https://sylorion.com/jcnm/en/posts/apple-container-framework-feedback/"><meta property="og:site_name" content="JCNM"><meta property="og:title" content="How We Experimented with Apple's Container Framework"><meta property="og:description" content="Discover our first experience with Apple's Container framework, a native containerization solution optimized for macOS and Apple Silicon, announced just a few days ago."><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-12T05:38:00+00:00"><meta property="article:modified_time" content="2025-06-12T05:38:00+00:00"><meta property="article:tag" content="Containerization"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Swift"><meta property="article:tag" content="MacOS"><meta property="article:tag" content="Apple Silicon"><meta property="og:image" content="https://sylorion.com/jcnm/images/apple_container_architecture.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sylorion.com/jcnm/images/apple_container_architecture.png"><meta name=twitter:title content="How We Experimented with Apple's Container Framework"><meta name=twitter:description content="Discover our first experience with Apple's Container framework, a native containerization solution optimized for macOS and Apple Silicon, announced just a few days ago."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sylorion.com/jcnm/en/posts/"},{"@type":"ListItem","position":2,"name":"How We Experimented with Apple's Container Framework","item":"https://sylorion.com/jcnm/en/posts/apple-container-framework-feedback/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How We Experimented with Apple's Container Framework","name":"How We Experimented with Apple\u0027s Container Framework","description":"Discover our first experience with Apple's Container framework, a native containerization solution optimized for macOS and Apple Silicon, announced just a few days ago.","keywords":["Apple Container","Containerization","Docker alternative","macOS containers","Apple Silicon development","Lightweight VMs","OCI","macOS virtualization"],"articleBody":"How We Experimented with Apple’s Container Framework Introduction (The “Why”) In the modern software development world, containerization has become an essential pillar of our infrastructure. It allows us to encapsulate our applications and their dependencies in isolated environments, ensuring consistency across different stages of the development cycle. However, for teams working on macOS, particularly on Macs equipped with Apple Silicon chips (M1/M2/M3/M4), this approach often comes with significant compromises.\nSince our migration to Apple Silicon Macs two years ago, our development team has regularly encountered challenges with traditional containerization solutions:\nSlow startup times that slow down our development cycles Excessive resource consumption (memory and CPU) by Docker Desktop Compatibility issues with certain container architectures Sometimes laborious integration with the native macOS ecosystem Suboptimal performance for intensive workloads These limitations directly impact our daily productivity. A developer who waits several seconds (or even tens of seconds) each time a container starts can lose valuable time over a full day. Similarly, a computer whose resources are monopolized by the containerization infrastructure becomes less responsive for other essential tasks.\nIt was in this context that Apple’s very recent announcement of its Container framework immediately caught our attention. Promising a native approach, optimized for Apple Silicon and harmoniously integrated with macOS, this new solution seemed to precisely address the challenges we were facing. But beyond the marketing promises, we wanted to concretely evaluate what this framework could bring to our daily workflow.\nOur team therefore decided to explore Apple’s Container framework in depth immediately after its announcement just a few days ago, to objectively compare it to our current solutions, and to evaluate its potential to transform our development environment. This article shares our first experience, our initial discoveries, and our preliminary recommendations for teams considering exploring this new technology.\nContext (The “What”) Apple’s Container framework represents a fundamentally new approach to containerization on macOS. Rather than being a simple Docker alternative, it’s a native solution specifically designed for the Apple ecosystem, and particularly optimized for Apple Silicon chips.\nWhat is Apple’s Container framework? At its core, Apple’s Container framework consists of two main elements:\nThe container tool: A command-line interface (CLI) written in Swift that allows creating and running Linux containers on macOS. This tool is the main entry point for developers.\nThe Containerization package: An underlying Swift library that provides the necessary APIs to manage containers, images, and processes. This package is the engine that powers the container tool.\nTogether, these components offer a complete solution for running Linux containers directly on macOS, without requiring a heavy emulation layer or shared virtual machine.\nAn architecture redesigned for performance What fundamentally distinguishes Apple’s Container framework from existing solutions is its technical architecture:\nOne VM per container: Each container runs in its own lightweight and optimized virtual machine, ensuring complete isolation. Optimized Linux kernel: A minimal and optimized Linux kernel allows startup times of less than a second. Native integration with Virtualization.framework: Direct use of Apple’s virtualization APIs for maximum performance. Lightweight init system (vminitd): A minimalist initialization system that starts quickly and consumes few resources. Rosetta 2 support: Ability to run x86_64 containers on Apple Silicon via Apple’s translation technology. This “one VM per container” approach offers not only performance advantages but also enhanced security. In case of container compromise, the attacker remains confined to an isolated VM, without access to other containers.\nCompatibility with the existing ecosystem Despite its innovative approach, Apple’s Container framework doesn’t isolate developers from the existing containerization ecosystem:\nOCI compliance: Full compatibility with Open Container Initiative (OCI) format images, the industry standard. Standard registries: Ability to retrieve and publish images from/to Docker Hub, GitHub Container Registry, and other standard registries. Familiar syntax: Commands similar to Docker to facilitate team transition. Multi-architecture support: Native management of ARM64 images and, via Rosetta 2, x86_64 images. This compatibility allows teams to explore Apple’s Container framework without major disruption to their existing workflows, while immediately benefiting from performance gains.\nPositioning relative to alternatives To clearly situate this solution in the current technological landscape:\nAspect Docker Desktop Podman Apple Container Framework Architecture Shared Linux VM Daemonless, rootless Dedicated VM per container Performance Moderate Good Excellent on Apple Silicon Memory footprint High (500MB-2GB) Medium Low (\u003c200MB) Startup time 3-5 seconds 2-3 seconds \u003c1 second Isolation Shared containers Isolated containers Isolated VMs macOS integration Via compatibility layer Via compatibility layer Native Maturity Very mature Mature Very recent (few days) Apple’s Container framework thus positions itself as a highly optimized solution for developers on macOS, particularly those using Apple Silicon machines, with an emphasis on performance, security, and native integration. Approach (The “How”) After discovering Apple’s Container framework during its announcement a few days ago, we immediately implemented a methodical approach to evaluate it and explore its potential for our workflow. Here’s how we proceeded, step by step, in this initial experimentation phase.\nInstallation and initial setup Our first step was to install the container tool on our development machines. The process proved remarkably simple:\nDownloading the installation package: We retrieved the latest signed package (.pkg) from Apple’s GitHub releases page, published very recently.\nStandard installation: A simple double-click on the package and entering the administrator password was sufficient to install the tool in /usr/local/.\nStarting the service: In the terminal, we initialized the service with the command:\n1 container system start This command automatically offered to download an optimized Linux kernel, which we accepted.\nVerifying the installation: We confirmed proper functioning with:\n1 2 container --version container ls -a Unlike other solutions that require complex configurations or multiple dependencies, the installation took less than 5 minutes per workstation, without any compatibility issues on our M1 and M2 Macs.\nFirst steps with the framework To familiarize ourselves with the tool, we started with simple operations:\nRetrieving images: We tested retrieving images from Docker Hub:\n1 2 container image pull nginx:alpine container image pull python:3.9 Running basic containers: We launched simple containers to verify functionality:\n1 container run --detach --name webserver --publish 8080:80 nginx:alpine Interacting with containers: We tested interaction commands:\n1 2 3 container ps container logs webserver container exec -it webserver sh These initial tests immediately highlighted the framework’s execution speed. Container startup was almost instantaneous, and system resource usage remained minimal even with several containers running.\nExploring Docker-equivalent commands To facilitate our experimentation, we created an equivalence table of the most commonly used commands:\nAction Docker Command Container Command List containers docker ps container ps List all images docker images container image list Run a container docker run container run Stop a container docker stop container stop Remove a container docker rm container rm Display logs docker logs container logs Execute a command docker exec container exec This syntactic similarity considerably facilitated our first steps with the tool. Most developers were able to transpose their habits without major learning effort.\nNetwork configuration and optimizations Since network management is a crucial aspect of our development infrastructure, we explored the framework’s capabilities in this area:\nBasic network configuration: On macOS 15, we used the traditional port publishing approach:\n1 container run --detach --name api --publish 3000:3000 our-api Advanced networking on macOS 26 Beta: On test machines with macOS 26 Beta, we explored advanced network features:\n1 2 3 4 5 6 # Creating a dedicated network container network create app-network # Deploying interconnected services container run --detach --name db --network app-network mongo container run --detach --name api --network app-network our-api This configuration allowed direct communication between containers without requiring port publishing, considerably simplifying our architecture.\nExploring volumes: We tested using volumes for local development:\n1 container run --volume /Users/dev/project:/app our-image Integration into our test environment For this initial experimentation phase, we created a representative test environment:\nAutomation scripts: We created shell scripts to standardize common operations:\n1 2 3 4 5 6 #!/bin/bash # start-dev-env.sh container system start container run --detach --name redis redis:alpine container run --detach --name postgres --env POSTGRES_PASSWORD=dev postgres:13 container run --detach --name app --publish 3000:3000 --volume $(pwd):/app our-app Tests with VS Code: We verified compatibility with VS Code via the Remote Containers extension, which proved functional with Apple’s Container framework.\nDocumentation of observations: We carefully documented our discoveries and created an experimentation guide for the entire team.\nThis exploratory approach allowed us to quickly evaluate Apple’s Container framework in the days following its announcement, and to gather initial impressions about its potential for our development environment.\nResults and Observations (The “What Happened”) After a few days of intensive experimentation with Apple’s Container framework since its announcement, we have collected preliminary data that allows us to objectively evaluate its potential for our development environment.\nComparative performance The first striking difference concerns performance. We systematically measured key metrics by comparing our usual configuration (Docker Desktop) with Apple’s Container framework:\nMetric Docker Desktop Apple Container Framework Improvement Cold start time 3.8 seconds 0.7 second 81% Memory usage at rest 1.2 GB 180 MB 85% CPU usage at rest 8-12% 1-2% ~85% Image build time 45 seconds 38 seconds 16% Image pull time Reference 20% faster 20% These preliminary figures are impressive: Apple’s Container framework offers substantial performance gains on all measured aspects. The most significant impact concerns container startup time and system resource usage, two points that directly affect developers’ daily experience.\nTo illustrate concretely: a developer who starts and stops 20 containers per day could save about 62 seconds of waiting time daily. Over a month of work, this would represent more than 20 minutes recovered, not counting the indirect benefits of a less taxed and therefore more responsive system.\nCompatibility with our existing projects A crucial aspect of our evaluation concerned compatibility with our existing ecosystem. Here are our initial observations:\nStandard Docker images: 100% of our usual Docker Hub images work without modification. Multi-architecture images: Excellent handling of native ARM64 images and good compatibility with x86_64 images via Rosetta 2. Volumes and persistence: Identical functionality to Docker for mounting local volumes. Networks: Equivalent basic features on macOS 15, promising advanced features on macOS 26 Beta. Development tools: Confirmed compatibility with VS Code, JetBrains, and other IDEs via their remote development extensions. We tested our typical development stack, which includes:\nA PostgreSQL database A Redis cache A Node.js API server A React frontend A Python processing service All these components worked without major modification in our test environment, requiring only adaptation of launch commands to use Apple Container framework syntax.\nObserved advantages Beyond pure metrics, several qualitative advantages emerged from our initial tests:\nPromising stability: We encountered no major incidents related to the containerization infrastructure (crashes, network issues, etc.) during our experimentation period.\nEnhanced security: The “one VM per container” architecture theoretically offers stronger isolation, particularly appreciated for testing potentially risky code.\nNative integration: Integration with macOS seems more fluid, particularly for credential management via Keychain and system resource usage.\nEase of use: The command-line interface is intuitive and consistent, with a very low learning curve for our team.\nSystem responsiveness: Developers report better overall responsiveness of their machines during tests, even with several containers running.\nLimitations and challenges encountered Our experience was not without obstacles. Here are the main limitations we identified in this initial phase:\nEcosystem maturity: As an extremely recent project, Apple’s Container framework doesn’t yet have as rich an ecosystem as Docker (graphical interfaces, monitoring tools, etc.).\nmacOS compatibility: Advanced network features require macOS 26 Beta, which limits their use in a production environment.\nDeveloping documentation: The documentation, although solid for such a recent project, is still developing, and some advanced use cases are less well covered.\nAbsence of Compose: The equivalent of Docker Compose for orchestrating multiple containers is not yet natively available, requiring custom scripts.\nBuild limitations: The image build system seems less flexible than Dockerfile for certain complex scenarios.\nInitial feedback from the development team We gathered the first impressions of our team after these few days of experimentation:\n85% of developers are enthusiastic and see significant potential in this solution 10% are neutral, finding the solution promising but preferring to wait for its maturation 5% are more reserved, mainly due to the youth of the project and uncertainty about its future evolution Positive comments mainly mention speed, lightness, and stability. Reservations mainly concern the youth of the project and uncertainty about its future evolution.\nA senior developer summarized the general feeling: “It’s like discovering a car designed specifically for our roads. Everything seems more natural, faster, and better integrated into our environment. But we’ll have to see how it behaves in the long term.”\nLessons Learned and Recommendations (The “So What?”) Our initial experimentation with Apple’s Container framework has allowed us to draw several preliminary lessons and formulate recommendations for teams considering exploring this new technology.\nPotentially ideal use cases for Apple’s Container framework Based on our initial tests, we have identified scenarios where this framework could particularly excel:\nDevelopment environments on Apple Silicon Macs: This is the quintessential use case, where performance gains seem most significant.\nTeams with resource constraints: For developers working on machines with limited resources (8GB of RAM for example), the framework’s lightness could make a considerable difference.\nProjects requiring frequent container starts: Workflows involving numerous start/stop cycles would benefit enormously from ultra-fast startup times.\nApplications requiring enhanced isolation: Projects handling sensitive data or executing unverified code could benefit from the VM-per-container isolation.\nMulti-container development environments: On macOS 26 Beta, advanced network management seems promising for simplifying multi-service architectures.\nOn the other hand, some use cases seem for now better served by alternative solutions:\nEnvironments requiring Docker Compose or complex orchestrators Workflows heavily dependent on graphical container management tools Teams using Intel Macs (not supported by the framework) Projects requiring advanced Docker features not yet implemented Identified best practices Our initial experience has allowed us to establish several best practices to get the most out of Apple’s Container framework:\nFavor native ARM64 images: Although Rosetta 2 allows running x86_64 images, performance seems significantly better with images compiled for ARM64.\nUse automation scripts: Creating shell scripts to replace Docker Compose functionality considerably simplifies managing multi-container environments.\nOptimize volumes: Limiting the number and size of mounted volumes seems to improve performance, particularly for applications handling many small files.\nAdopt a “stateless” approach: Designing containers to be ephemeral and stateless facilitates their management with Apple’s Container framework.\nStandardize commands: Creating shell aliases or functions to standardize commands between Docker and the Container framework simplifies experimentation.\nActively follow updates: As the framework is in very active development, significant improvements are likely to be published regularly.\nTips for effective exploration For teams considering exploring Apple’s Container framework, here is our recommended roadmap:\nDiscovery phase: Start by installing and testing the tool on a non-critical project to evaluate compatibility and performance.\nProgressive approach: Experiment project by project rather than switching all infrastructure at once.\nDocumentation of equivalences: Create an internal guide of equivalences between Docker and Container commands.\nExperience sharing: Organize short demonstration sessions (30-60 minutes) to present new possibilities to the team.\nParallel environment: Maintain both solutions in parallel during the exploration phase.\nContinuous feedback: Set up a dedicated channel to collect experience feedback and document discoveries.\nConsiderations for different types of teams Exploration of Apple’s Container framework should be adapted to each team’s specific context:\nFor small teams (1-5 developers):\nExperimentation can be quick and informal Performance gains are immediately perceptible The absence of certain graphical tools can be compensated by custom scripts For medium teams (5-15 developers):\nA more structured approach is recommended Designate an “explorer” responsible for evaluation and sharing discoveries Formally document observations and tested use cases Plan for a more methodical exploration phase For large teams (15+ developers):\nCreate a dedicated exploration group to test and document possibilities Develop prototypes of internal tools to fill ecosystem gaps Implement formal evaluation Consider limited tests in non-critical environments Plan for phased exploration with clear objectives Potential impact on productivity and satisfaction Beyond technical aspects, we observed potential impacts on more subjective but equally important factors:\nReduced frustration: Reduced waiting times and apparent stability could decrease workflow interruptions. Increased satisfaction: Developers seem to appreciate working with tools optimized for their hardware. Sense of belonging: Using native Apple technology on Apple hardware creates a more coherent and integrated experience. Reduced “mental tax”: Less cognitive resources seem devoted to infrastructure management, allowing better focus on code. These factors, although difficult to quantify in this preliminary phase, could significantly contribute to the overall improvement of the development experience if the framework fulfills its promises in the long term.\nConclusion and Perspectives Our initial exploration of Apple’s Container framework, just days after its announcement, has allowed us to glimpse the potential of this new approach to containerization on macOS. What began as simple technical curiosity quickly transformed into a promising evaluation, with encouraging preliminary results.\nSummary of key points Apple’s Container framework distinguishes itself through several fundamental characteristics:\nNative performance on Apple Silicon: Startup times under one second and memory footprint reduced by 85% compared to Docker Desktop in our initial tests. Secure architecture: VM isolation theoretically offers enhanced security without compromising performance. OCI compatibility: Seamless integration with the existing container ecosystem facilitates experimentation. macOS integration: Using Apple’s native technologies (Virtualization.framework, Keychain, etc.) creates a coherent and optimized experience. These advantages could translate into concrete improvement of our daily productivity, with fewer interruptions, better stability, and more efficient use of our machines’ resources.\nExpected evolution of the framework and ecosystem As Apple’s Container framework is an extremely recent project, we anticipate several significant evolutions in the coming months:\nEcosystem maturation: Progressive development of complementary tools, graphical interfaces, and integrations with popular IDEs.\nImprovement of network features: Probable extension of advanced network capabilities to standard macOS after the beta period.\nCompose equivalent: Possible emergence of a native or third-party solution for multi-container orchestration, filling one of the current main gaps.\nCI/CD integration: Expected development of better support in continuous integration and deployment pipelines.\nAdditional optimizations: Continuous improvements in performance and resource management through updates.\nThe community is just beginning to organize around this framework, with the appearance of the first help forums and experience sharing. This nascent dynamic suggests a potentially rich and diverse ecosystem in the coming months.\nOur vision for the future of containerization on macOS In the longer term, we see Apple’s Container framework as a possible catalyst for change in the macOS development ecosystem. This native approach, optimized for Apple hardware, could redefine developers’ expectations regarding performance and integration.\nWe anticipate a progressive convergence of development tools towards this “native first” approach, where third-party solutions may increasingly rely on Apple’s native frameworks rather than compatibility layers.\nThis evolution would fit into a broader trend of optimizing development tools for ARM architectures, which are progressively becoming dominant in the industry. Apple’s Container framework could thus serve as a model for other platforms in the future.\nNext steps for our team Following this encouraging first experimentation, our plan for the coming weeks includes:\nIn-depth exploration: Continue testing the framework on more varied projects and in conditions closer to production.\nDevelopment of tool prototypes: Create scripts and utilities to fill current ecosystem gaps, particularly a lightweight equivalent of Docker Compose.\nKnowledge sharing: Organize demonstration sessions for the entire team and document our discoveries.\nLonger-term evaluation: Set up a pilot project using exclusively the Container framework to evaluate its viability over a longer period.\nTechnology watch: Actively follow the framework’s evolution and adapt our exploration strategy accordingly.\nUltimately, our first experience with Apple’s Container framework, although very recent, has allowed us to glimpse the potential of a technology that could transform the development experience on macOS. If the initial promises are confirmed and the ecosystem develops as hoped, this solution could become a valuable tool in our development arsenal. We will continue to explore its possibilities and share our discoveries with the community as it evolves.\nAdditional Resources To deepen your knowledge of Apple’s Container framework and facilitate your own exploration, here is a selection of resources we found particularly useful in these early days.\nOfficial documentation Container Project GitHub - The official repository containing the source code, documentation, and installation guides. Containerization Package GitHub - The repository of the underlying Swift package that powers the Container tool. Containerization API Documentation - The complete technical documentation of the framework’s Swift APIs. Technical Overview - A detailed explanation of the architecture and key concepts. Tutorials and practical guides Quick Start Guide - A step-by-step tutorial to build, run, and publish your first container. Features Guide - A comprehensive overview of available features and their usage. WWDC25 Presentation: Meet Containerization - The official presentation of the framework by the Apple team. Migration Guide from Docker - A detailed guide to facilitate transition from Docker. Complementary tools Kata Containers - An alternative source of optimized Linux kernels compatible with the framework. Swiftly - A tool to easily install and manage Swift environments, useful for development with Containerization. VS Code Remote Containers - VS Code extension compatible with Apple’s Container framework. Community and support GitHub Discussion Forum - The official space to ask questions and share experiences. Swift Server Slack Channel - A channel dedicated to discussions on Swift server technologies, including Containerization. Stack Overflow: Tag container-apple - Community questions and answers. Articles and analyses Comparative Performance Analysis - A detailed study of the framework’s performance compared to alternatives. Security Implications - An analysis of the security advantages of the “one VM per container” architecture. The Future of Containerization on macOS - A reflection on the potential impact of the framework on the development ecosystem. Models and examples Automation Scripts - A collection of shell scripts to automate common workflows. Containerized Application Examples - Concrete examples of various applications configured for Apple’s Container framework. These resources will allow you to deepen your understanding of the framework and explore it effectively according to your specific needs. Feel free to contribute to this nascent ecosystem by sharing your own experiences and discoveries with the community.\n","wordCount":"3650","inLanguage":"en","image":"https://sylorion.com/jcnm/images/apple_container_architecture.png","datePublished":"2025-06-12T05:38:00Z","dateModified":"2025-06-12T05:38:00Z","author":{"@type":"Person","name":"Services CEO DevOps Team"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sylorion.com/jcnm/en/posts/apple-container-framework-feedback/"},"publisher":{"@type":"Organization","name":"JCNM","logo":{"@type":"ImageObject","url":"https://sylorion.com/jcnm/images/icon32x32.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sylorion.com/jcnm/en/ accesskey=h title="JCNM (Alt + H)"><img src=https://sylorion.com/jcnm/images/icon.png alt aria-label=logo height=35>JCNM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://sylorion.com/jcnm/ title="🇫🇷 Français" aria-label="🇫🇷 Français">Fr</a></li></ul></div></div><ul id=menu><li><a href=https://sylorion.com/jcnm/en/posts title=Posts><span>Posts</span></a></li><li><a href=https://sylorion.com/jcnm/en/categories title=Categories><span>Categories</span></a></li><li><a href=https://sylorion.com/jcnm/en/tags title=Tags><span>Tags</span></a></li><li><a href=https://sylorion.com/jcnm/en/contact title=Contact><span>Contact</span></a></li><li><a href=https://sylorion.com/jcnm/en/about title=About><span>About</span></a></li><li><a href=https://github.com/jcnm/blog title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sylorion.com/jcnm/en/>Home</a>&nbsp;»&nbsp;<a href=https://sylorion.com/jcnm/en/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How We Experimented with Apple's Container Framework</h1><div class=post-description>Discover our first experience with Apple's Container framework, a native containerization solution optimized for macOS and Apple Silicon, announced just a few days ago.</div><div class=post-meta><span title='2025-06-12 05:38:00 +0000 +0000'>June 12, 2025</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;3650 words&nbsp;·&nbsp;Services CEO DevOps Team&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://sylorion.com/jcnm/posts/apple-container-framework-tests-et-retours/>Fr</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/jcnm/blog/tree/main/content/posts/apple-container-framework-feedback.md rel="noopener noreferrer" target=_blank>✍️</a></div></header><figure class=entry-cover><img loading=eager src=https://sylorion.com/jcnm/images/apple_container_architecture.png alt="Apple container architecture"></figure><div class=post-content><h1 id=how-we-experimented-with-apples-container-framework>How We Experimented with Apple&rsquo;s Container Framework<a hidden class=anchor aria-hidden=true href=#how-we-experimented-with-apples-container-framework>#</a></h1><h2 id=introduction-the-why>Introduction (The &ldquo;Why&rdquo;)<a hidden class=anchor aria-hidden=true href=#introduction-the-why>#</a></h2><p>In the modern software development world, containerization has become an essential pillar of our infrastructure. It allows us to encapsulate our applications and their dependencies in isolated environments, ensuring consistency across different stages of the development cycle. However, for teams working on macOS, particularly on Macs equipped with Apple Silicon chips (M1/M2/M3/M4), this approach often comes with significant compromises.</p><p>Since our migration to Apple Silicon Macs two years ago, our development team has regularly encountered challenges with traditional containerization solutions:</p><ul><li>Slow startup times that slow down our development cycles</li><li>Excessive resource consumption (memory and CPU) by Docker Desktop</li><li>Compatibility issues with certain container architectures</li><li>Sometimes laborious integration with the native macOS ecosystem</li><li>Suboptimal performance for intensive workloads</li></ul><p>These limitations directly impact our daily productivity. A developer who waits several seconds (or even tens of seconds) each time a container starts can lose valuable time over a full day. Similarly, a computer whose resources are monopolized by the containerization infrastructure becomes less responsive for other essential tasks.</p><p>It was in this context that Apple&rsquo;s very recent announcement of its Container framework immediately caught our attention. Promising a native approach, optimized for Apple Silicon and harmoniously integrated with macOS, this new solution seemed to precisely address the challenges we were facing. But beyond the marketing promises, we wanted to concretely evaluate what this framework could bring to our daily workflow.</p><p>Our team therefore decided to explore Apple&rsquo;s Container framework in depth immediately after its announcement just a few days ago, to objectively compare it to our current solutions, and to evaluate its potential to transform our development environment. This article shares our first experience, our initial discoveries, and our preliminary recommendations for teams considering exploring this new technology.</p><h2 id=context-the-what>Context (The &ldquo;What&rdquo;)<a hidden class=anchor aria-hidden=true href=#context-the-what>#</a></h2><p>Apple&rsquo;s Container framework represents a fundamentally new approach to containerization on macOS. Rather than being a simple Docker alternative, it&rsquo;s a native solution specifically designed for the Apple ecosystem, and particularly optimized for Apple Silicon chips.</p><h3 id=what-is-apples-container-framework>What is Apple&rsquo;s Container framework?<a hidden class=anchor aria-hidden=true href=#what-is-apples-container-framework>#</a></h3><p>At its core, Apple&rsquo;s Container framework consists of two main elements:</p><ol><li><p><strong>The <code>container</code> tool</strong>: A command-line interface (CLI) written in Swift that allows creating and running Linux containers on macOS. This tool is the main entry point for developers.</p></li><li><p><strong>The Containerization package</strong>: An underlying Swift library that provides the necessary APIs to manage containers, images, and processes. This package is the engine that powers the <code>container</code> tool.</p></li></ol><p>Together, these components offer a complete solution for running Linux containers directly on macOS, without requiring a heavy emulation layer or shared virtual machine.</p><h3 id=an-architecture-redesigned-for-performance>An architecture redesigned for performance<a hidden class=anchor aria-hidden=true href=#an-architecture-redesigned-for-performance>#</a></h3><p>What fundamentally distinguishes Apple&rsquo;s Container framework from existing solutions is its technical architecture:</p><ul><li><strong>One VM per container</strong>: Each container runs in its own lightweight and optimized virtual machine, ensuring complete isolation.</li><li><strong>Optimized Linux kernel</strong>: A minimal and optimized Linux kernel allows startup times of less than a second.</li><li><strong>Native integration with Virtualization.framework</strong>: Direct use of Apple&rsquo;s virtualization APIs for maximum performance.</li><li><strong>Lightweight init system (vminitd)</strong>: A minimalist initialization system that starts quickly and consumes few resources.</li><li><strong>Rosetta 2 support</strong>: Ability to run x86_64 containers on Apple Silicon via Apple&rsquo;s translation technology.</li></ul><p>This &ldquo;one VM per container&rdquo; approach offers not only performance advantages but also enhanced security. In case of container compromise, the attacker remains confined to an isolated VM, without access to other containers.</p><h3 id=compatibility-with-the-existing-ecosystem>Compatibility with the existing ecosystem<a hidden class=anchor aria-hidden=true href=#compatibility-with-the-existing-ecosystem>#</a></h3><p>Despite its innovative approach, Apple&rsquo;s Container framework doesn&rsquo;t isolate developers from the existing containerization ecosystem:</p><ul><li><strong>OCI compliance</strong>: Full compatibility with Open Container Initiative (OCI) format images, the industry standard.</li><li><strong>Standard registries</strong>: Ability to retrieve and publish images from/to Docker Hub, GitHub Container Registry, and other standard registries.</li><li><strong>Familiar syntax</strong>: Commands similar to Docker to facilitate team transition.</li><li><strong>Multi-architecture support</strong>: Native management of ARM64 images and, via Rosetta 2, x86_64 images.</li></ul><p>This compatibility allows teams to explore Apple&rsquo;s Container framework without major disruption to their existing workflows, while immediately benefiting from performance gains.</p><h3 id=positioning-relative-to-alternatives>Positioning relative to alternatives<a hidden class=anchor aria-hidden=true href=#positioning-relative-to-alternatives>#</a></h3><p>To clearly situate this solution in the current technological landscape:</p><table><thead><tr><th>Aspect</th><th>Docker Desktop</th><th>Podman</th><th>Apple Container Framework</th></tr></thead><tbody><tr><td><strong>Architecture</strong></td><td>Shared Linux VM</td><td>Daemonless, rootless</td><td>Dedicated VM per container</td></tr><tr><td><strong>Performance</strong></td><td>Moderate</td><td>Good</td><td>Excellent on Apple Silicon</td></tr><tr><td><strong>Memory footprint</strong></td><td>High (500MB-2GB)</td><td>Medium</td><td>Low (&lt;200MB)</td></tr><tr><td><strong>Startup time</strong></td><td>3-5 seconds</td><td>2-3 seconds</td><td>&lt;1 second</td></tr><tr><td><strong>Isolation</strong></td><td>Shared containers</td><td>Isolated containers</td><td>Isolated VMs</td></tr><tr><td><strong>macOS integration</strong></td><td>Via compatibility layer</td><td>Via compatibility layer</td><td>Native</td></tr><tr><td><strong>Maturity</strong></td><td>Very mature</td><td>Mature</td><td>Very recent (few days)</td></tr></tbody></table><p>Apple&rsquo;s Container framework thus positions itself as a highly optimized solution for developers on macOS, particularly those using Apple Silicon machines, with an emphasis on performance, security, and native integration.<figure class=align-center><img loading=lazy src=/jcnm/images/apple_container_vs_docker.png#center></figure></p><h2 id=approach-the-how>Approach (The &ldquo;How&rdquo;)<a hidden class=anchor aria-hidden=true href=#approach-the-how>#</a></h2><p>After discovering Apple&rsquo;s Container framework during its announcement a few days ago, we immediately implemented a methodical approach to evaluate it and explore its potential for our workflow. Here&rsquo;s how we proceeded, step by step, in this initial experimentation phase.</p><h3 id=installation-and-initial-setup>Installation and initial setup<a hidden class=anchor aria-hidden=true href=#installation-and-initial-setup>#</a></h3><p>Our first step was to install the <code>container</code> tool on our development machines. The process proved remarkably simple:</p><ol><li><p><strong>Downloading the installation package</strong>: We retrieved the latest signed package (.pkg) from Apple&rsquo;s GitHub releases page, published very recently.</p></li><li><p><strong>Standard installation</strong>: A simple double-click on the package and entering the administrator password was sufficient to install the tool in <code>/usr/local/</code>.</p></li><li><p><strong>Starting the service</strong>: In the terminal, we initialized the service with the command:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container system start
</span></span></code></pre></td></tr></table></div></div><p>This command automatically offered to download an optimized Linux kernel, which we accepted.</p></li><li><p><strong>Verifying the installation</strong>: We confirmed proper functioning with:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container --version
</span></span><span class=line><span class=cl>container ls -a
</span></span></code></pre></td></tr></table></div></div></li></ol><p>Unlike other solutions that require complex configurations or multiple dependencies, the installation took less than 5 minutes per workstation, without any compatibility issues on our M1 and M2 Macs.</p><h3 id=first-steps-with-the-framework>First steps with the framework<a hidden class=anchor aria-hidden=true href=#first-steps-with-the-framework>#</a></h3><p>To familiarize ourselves with the tool, we started with simple operations:</p><ol><li><p><strong>Retrieving images</strong>: We tested retrieving images from Docker Hub:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container image pull nginx:alpine
</span></span><span class=line><span class=cl>container image pull python:3.9
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Running basic containers</strong>: We launched simple containers to verify functionality:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container run --detach --name webserver --publish 8080:80 nginx:alpine
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Interacting with containers</strong>: We tested interaction commands:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container ps
</span></span><span class=line><span class=cl>container logs webserver
</span></span><span class=line><span class=cl>container <span class=nb>exec</span> -it webserver sh
</span></span></code></pre></td></tr></table></div></div></li></ol><p>These initial tests immediately highlighted the framework&rsquo;s execution speed. Container startup was almost instantaneous, and system resource usage remained minimal even with several containers running.</p><h3 id=exploring-docker-equivalent-commands>Exploring Docker-equivalent commands<a hidden class=anchor aria-hidden=true href=#exploring-docker-equivalent-commands>#</a></h3><p>To facilitate our experimentation, we created an equivalence table of the most commonly used commands:</p><table><thead><tr><th>Action</th><th>Docker Command</th><th>Container Command</th></tr></thead><tbody><tr><td>List containers</td><td><code>docker ps</code></td><td><code>container ps</code></td></tr><tr><td>List all images</td><td><code>docker images</code></td><td><code>container image list</code></td></tr><tr><td>Run a container</td><td><code>docker run</code></td><td><code>container run</code></td></tr><tr><td>Stop a container</td><td><code>docker stop</code></td><td><code>container stop</code></td></tr><tr><td>Remove a container</td><td><code>docker rm</code></td><td><code>container rm</code></td></tr><tr><td>Display logs</td><td><code>docker logs</code></td><td><code>container logs</code></td></tr><tr><td>Execute a command</td><td><code>docker exec</code></td><td><code>container exec</code></td></tr></tbody></table><p>This syntactic similarity considerably facilitated our first steps with the tool. Most developers were able to transpose their habits without major learning effort.</p><h3 id=network-configuration-and-optimizations>Network configuration and optimizations<a hidden class=anchor aria-hidden=true href=#network-configuration-and-optimizations>#</a></h3><p>Since network management is a crucial aspect of our development infrastructure, we explored the framework&rsquo;s capabilities in this area:</p><ol><li><p><strong>Basic network configuration</strong>: On macOS 15, we used the traditional port publishing approach:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container run --detach --name api --publish 3000:3000 our-api
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Advanced networking on macOS 26 Beta</strong>: On test machines with macOS 26 Beta, we explored advanced network features:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Creating a dedicated network</span>
</span></span><span class=line><span class=cl>container network create app-network
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Deploying interconnected services</span>
</span></span><span class=line><span class=cl>container run --detach --name db --network app-network mongo
</span></span><span class=line><span class=cl>container run --detach --name api --network app-network our-api
</span></span></code></pre></td></tr></table></div></div><p>This configuration allowed direct communication between containers without requiring port publishing, considerably simplifying our architecture.</p></li><li><p><strong>Exploring volumes</strong>: We tested using volumes for local development:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container run --volume /Users/dev/project:/app our-image
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=integration-into-our-test-environment>Integration into our test environment<a hidden class=anchor aria-hidden=true href=#integration-into-our-test-environment>#</a></h3><p>For this initial experimentation phase, we created a representative test environment:</p><ol><li><p><strong>Automation scripts</strong>: We created shell scripts to standardize common operations:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1># start-dev-env.sh</span>
</span></span><span class=line><span class=cl>container system start
</span></span><span class=line><span class=cl>container run --detach --name redis redis:alpine
</span></span><span class=line><span class=cl>container run --detach --name postgres --env <span class=nv>POSTGRES_PASSWORD</span><span class=o>=</span>dev postgres:13
</span></span><span class=line><span class=cl>container run --detach --name app --publish 3000:3000 --volume <span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span>:/app our-app
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Tests with VS Code</strong>: We verified compatibility with VS Code via the Remote Containers extension, which proved functional with Apple&rsquo;s Container framework.</p></li><li><p><strong>Documentation of observations</strong>: We carefully documented our discoveries and created an experimentation guide for the entire team.</p></li></ol><p>This exploratory approach allowed us to quickly evaluate Apple&rsquo;s Container framework in the days following its announcement, and to gather initial impressions about its potential for our development environment.</p><h2 id=results-and-observations-the-what-happened>Results and Observations (The &ldquo;What Happened&rdquo;)<a hidden class=anchor aria-hidden=true href=#results-and-observations-the-what-happened>#</a></h2><p>After a few days of intensive experimentation with Apple&rsquo;s Container framework since its announcement, we have collected preliminary data that allows us to objectively evaluate its potential for our development environment.</p><h3 id=comparative-performance>Comparative performance<a hidden class=anchor aria-hidden=true href=#comparative-performance>#</a></h3><p>The first striking difference concerns performance. We systematically measured key metrics by comparing our usual configuration (Docker Desktop) with Apple&rsquo;s Container framework:</p><table><thead><tr><th>Metric</th><th>Docker Desktop</th><th>Apple Container Framework</th><th>Improvement</th></tr></thead><tbody><tr><td>Cold start time</td><td>3.8 seconds</td><td>0.7 second</td><td><strong>81%</strong></td></tr><tr><td>Memory usage at rest</td><td>1.2 GB</td><td>180 MB</td><td><strong>85%</strong></td></tr><tr><td>CPU usage at rest</td><td>8-12%</td><td>1-2%</td><td><strong>~85%</strong></td></tr><tr><td>Image build time</td><td>45 seconds</td><td>38 seconds</td><td><strong>16%</strong></td></tr><tr><td>Image pull time</td><td>Reference</td><td>20% faster</td><td><strong>20%</strong></td></tr></tbody></table><p>These preliminary figures are impressive: Apple&rsquo;s Container framework offers substantial performance gains on all measured aspects. The most significant impact concerns container startup time and system resource usage, two points that directly affect developers&rsquo; daily experience.</p><p>To illustrate concretely: a developer who starts and stops 20 containers per day could save about 62 seconds of waiting time daily. Over a month of work, this would represent more than 20 minutes recovered, not counting the indirect benefits of a less taxed and therefore more responsive system.</p><h3 id=compatibility-with-our-existing-projects>Compatibility with our existing projects<a hidden class=anchor aria-hidden=true href=#compatibility-with-our-existing-projects>#</a></h3><p>A crucial aspect of our evaluation concerned compatibility with our existing ecosystem. Here are our initial observations:</p><ul><li><strong>Standard Docker images</strong>: 100% of our usual Docker Hub images work without modification.</li><li><strong>Multi-architecture images</strong>: Excellent handling of native ARM64 images and good compatibility with x86_64 images via Rosetta 2.</li><li><strong>Volumes and persistence</strong>: Identical functionality to Docker for mounting local volumes.</li><li><strong>Networks</strong>: Equivalent basic features on macOS 15, promising advanced features on macOS 26 Beta.</li><li><strong>Development tools</strong>: Confirmed compatibility with VS Code, JetBrains, and other IDEs via their remote development extensions.</li></ul><p>We tested our typical development stack, which includes:</p><ul><li>A PostgreSQL database</li><li>A Redis cache</li><li>A Node.js API server</li><li>A React frontend</li><li>A Python processing service</li></ul><p>All these components worked without major modification in our test environment, requiring only adaptation of launch commands to use Apple Container framework syntax.</p><h3 id=observed-advantages>Observed advantages<a hidden class=anchor aria-hidden=true href=#observed-advantages>#</a></h3><p>Beyond pure metrics, several qualitative advantages emerged from our initial tests:</p><ol><li><p><strong>Promising stability</strong>: We encountered no major incidents related to the containerization infrastructure (crashes, network issues, etc.) during our experimentation period.</p></li><li><p><strong>Enhanced security</strong>: The &ldquo;one VM per container&rdquo; architecture theoretically offers stronger isolation, particularly appreciated for testing potentially risky code.</p></li><li><p><strong>Native integration</strong>: Integration with macOS seems more fluid, particularly for credential management via Keychain and system resource usage.</p></li><li><p><strong>Ease of use</strong>: The command-line interface is intuitive and consistent, with a very low learning curve for our team.</p></li><li><p><strong>System responsiveness</strong>: Developers report better overall responsiveness of their machines during tests, even with several containers running.</p></li></ol><h3 id=limitations-and-challenges-encountered>Limitations and challenges encountered<a hidden class=anchor aria-hidden=true href=#limitations-and-challenges-encountered>#</a></h3><p>Our experience was not without obstacles. Here are the main limitations we identified in this initial phase:</p><ol><li><p><strong>Ecosystem maturity</strong>: As an extremely recent project, Apple&rsquo;s Container framework doesn&rsquo;t yet have as rich an ecosystem as Docker (graphical interfaces, monitoring tools, etc.).</p></li><li><p><strong>macOS compatibility</strong>: Advanced network features require macOS 26 Beta, which limits their use in a production environment.</p></li><li><p><strong>Developing documentation</strong>: The documentation, although solid for such a recent project, is still developing, and some advanced use cases are less well covered.</p></li><li><p><strong>Absence of Compose</strong>: The equivalent of Docker Compose for orchestrating multiple containers is not yet natively available, requiring custom scripts.</p></li><li><p><strong>Build limitations</strong>: The image build system seems less flexible than Dockerfile for certain complex scenarios.</p></li></ol><h3 id=initial-feedback-from-the-development-team>Initial feedback from the development team<a hidden class=anchor aria-hidden=true href=#initial-feedback-from-the-development-team>#</a></h3><p>We gathered the first impressions of our team after these few days of experimentation:</p><ul><li>85% of developers are enthusiastic and see significant potential in this solution</li><li>10% are neutral, finding the solution promising but preferring to wait for its maturation</li><li>5% are more reserved, mainly due to the youth of the project and uncertainty about its future evolution</li></ul><p>Positive comments mainly mention speed, lightness, and stability. Reservations mainly concern the youth of the project and uncertainty about its future evolution.</p><p>A senior developer summarized the general feeling: &ldquo;It&rsquo;s like discovering a car designed specifically for our roads. Everything seems more natural, faster, and better integrated into our environment. But we&rsquo;ll have to see how it behaves in the long term.&rdquo;</p><h2 id=lessons-learned-and-recommendations-the-so-what>Lessons Learned and Recommendations (The &ldquo;So What?&rdquo;)<a hidden class=anchor aria-hidden=true href=#lessons-learned-and-recommendations-the-so-what>#</a></h2><p>Our initial experimentation with Apple&rsquo;s Container framework has allowed us to draw several preliminary lessons and formulate recommendations for teams considering exploring this new technology.</p><h3 id=potentially-ideal-use-cases-for-apples-container-framework>Potentially ideal use cases for Apple&rsquo;s Container framework<a hidden class=anchor aria-hidden=true href=#potentially-ideal-use-cases-for-apples-container-framework>#</a></h3><p>Based on our initial tests, we have identified scenarios where this framework could particularly excel:</p><ol><li><p><strong>Development environments on Apple Silicon Macs</strong>: This is the quintessential use case, where performance gains seem most significant.</p></li><li><p><strong>Teams with resource constraints</strong>: For developers working on machines with limited resources (8GB of RAM for example), the framework&rsquo;s lightness could make a considerable difference.</p></li><li><p><strong>Projects requiring frequent container starts</strong>: Workflows involving numerous start/stop cycles would benefit enormously from ultra-fast startup times.</p></li><li><p><strong>Applications requiring enhanced isolation</strong>: Projects handling sensitive data or executing unverified code could benefit from the VM-per-container isolation.</p></li><li><p><strong>Multi-container development environments</strong>: On macOS 26 Beta, advanced network management seems promising for simplifying multi-service architectures.</p></li></ol><p>On the other hand, some use cases seem for now better served by alternative solutions:</p><ul><li>Environments requiring Docker Compose or complex orchestrators</li><li>Workflows heavily dependent on graphical container management tools</li><li>Teams using Intel Macs (not supported by the framework)</li><li>Projects requiring advanced Docker features not yet implemented</li></ul><h3 id=identified-best-practices>Identified best practices<a hidden class=anchor aria-hidden=true href=#identified-best-practices>#</a></h3><p>Our initial experience has allowed us to establish several best practices to get the most out of Apple&rsquo;s Container framework:</p><ol><li><p><strong>Favor native ARM64 images</strong>: Although Rosetta 2 allows running x86_64 images, performance seems significantly better with images compiled for ARM64.</p></li><li><p><strong>Use automation scripts</strong>: Creating shell scripts to replace Docker Compose functionality considerably simplifies managing multi-container environments.</p></li><li><p><strong>Optimize volumes</strong>: Limiting the number and size of mounted volumes seems to improve performance, particularly for applications handling many small files.</p></li><li><p><strong>Adopt a &ldquo;stateless&rdquo; approach</strong>: Designing containers to be ephemeral and stateless facilitates their management with Apple&rsquo;s Container framework.</p></li><li><p><strong>Standardize commands</strong>: Creating shell aliases or functions to standardize commands between Docker and the Container framework simplifies experimentation.</p></li><li><p><strong>Actively follow updates</strong>: As the framework is in very active development, significant improvements are likely to be published regularly.</p></li></ol><h3 id=tips-for-effective-exploration>Tips for effective exploration<a hidden class=anchor aria-hidden=true href=#tips-for-effective-exploration>#</a></h3><p>For teams considering exploring Apple&rsquo;s Container framework, here is our recommended roadmap:</p><ol><li><p><strong>Discovery phase</strong>: Start by installing and testing the tool on a non-critical project to evaluate compatibility and performance.</p></li><li><p><strong>Progressive approach</strong>: Experiment project by project rather than switching all infrastructure at once.</p></li><li><p><strong>Documentation of equivalences</strong>: Create an internal guide of equivalences between Docker and Container commands.</p></li><li><p><strong>Experience sharing</strong>: Organize short demonstration sessions (30-60 minutes) to present new possibilities to the team.</p></li><li><p><strong>Parallel environment</strong>: Maintain both solutions in parallel during the exploration phase.</p></li><li><p><strong>Continuous feedback</strong>: Set up a dedicated channel to collect experience feedback and document discoveries.</p></li></ol><h3 id=considerations-for-different-types-of-teams>Considerations for different types of teams<a hidden class=anchor aria-hidden=true href=#considerations-for-different-types-of-teams>#</a></h3><p>Exploration of Apple&rsquo;s Container framework should be adapted to each team&rsquo;s specific context:</p><p><strong>For small teams (1-5 developers)</strong>:</p><ul><li>Experimentation can be quick and informal</li><li>Performance gains are immediately perceptible</li><li>The absence of certain graphical tools can be compensated by custom scripts</li></ul><p><strong>For medium teams (5-15 developers)</strong>:</p><ul><li>A more structured approach is recommended</li><li>Designate an &ldquo;explorer&rdquo; responsible for evaluation and sharing discoveries</li><li>Formally document observations and tested use cases</li><li>Plan for a more methodical exploration phase</li></ul><p><strong>For large teams (15+ developers)</strong>:</p><ul><li>Create a dedicated exploration group to test and document possibilities</li><li>Develop prototypes of internal tools to fill ecosystem gaps</li><li>Implement formal evaluation</li><li>Consider limited tests in non-critical environments</li><li>Plan for phased exploration with clear objectives</li></ul><h3 id=potential-impact-on-productivity-and-satisfaction>Potential impact on productivity and satisfaction<a hidden class=anchor aria-hidden=true href=#potential-impact-on-productivity-and-satisfaction>#</a></h3><p>Beyond technical aspects, we observed potential impacts on more subjective but equally important factors:</p><ul><li><strong>Reduced frustration</strong>: Reduced waiting times and apparent stability could decrease workflow interruptions.</li><li><strong>Increased satisfaction</strong>: Developers seem to appreciate working with tools optimized for their hardware.</li><li><strong>Sense of belonging</strong>: Using native Apple technology on Apple hardware creates a more coherent and integrated experience.</li><li><strong>Reduced &ldquo;mental tax&rdquo;</strong>: Less cognitive resources seem devoted to infrastructure management, allowing better focus on code.</li></ul><p>These factors, although difficult to quantify in this preliminary phase, could significantly contribute to the overall improvement of the development experience if the framework fulfills its promises in the long term.</p><h2 id=conclusion-and-perspectives>Conclusion and Perspectives<a hidden class=anchor aria-hidden=true href=#conclusion-and-perspectives>#</a></h2><p>Our initial exploration of Apple&rsquo;s Container framework, just days after its announcement, has allowed us to glimpse the potential of this new approach to containerization on macOS. What began as simple technical curiosity quickly transformed into a promising evaluation, with encouraging preliminary results.</p><h3 id=summary-of-key-points>Summary of key points<a hidden class=anchor aria-hidden=true href=#summary-of-key-points>#</a></h3><p>Apple&rsquo;s Container framework distinguishes itself through several fundamental characteristics:</p><ul><li><strong>Native performance on Apple Silicon</strong>: Startup times under one second and memory footprint reduced by 85% compared to Docker Desktop in our initial tests.</li><li><strong>Secure architecture</strong>: VM isolation theoretically offers enhanced security without compromising performance.</li><li><strong>OCI compatibility</strong>: Seamless integration with the existing container ecosystem facilitates experimentation.</li><li><strong>macOS integration</strong>: Using Apple&rsquo;s native technologies (Virtualization.framework, Keychain, etc.) creates a coherent and optimized experience.</li></ul><p>These advantages could translate into concrete improvement of our daily productivity, with fewer interruptions, better stability, and more efficient use of our machines&rsquo; resources.</p><h3 id=expected-evolution-of-the-framework-and-ecosystem>Expected evolution of the framework and ecosystem<a hidden class=anchor aria-hidden=true href=#expected-evolution-of-the-framework-and-ecosystem>#</a></h3><p>As Apple&rsquo;s Container framework is an extremely recent project, we anticipate several significant evolutions in the coming months:</p><ol><li><p><strong>Ecosystem maturation</strong>: Progressive development of complementary tools, graphical interfaces, and integrations with popular IDEs.</p></li><li><p><strong>Improvement of network features</strong>: Probable extension of advanced network capabilities to standard macOS after the beta period.</p></li><li><p><strong>Compose equivalent</strong>: Possible emergence of a native or third-party solution for multi-container orchestration, filling one of the current main gaps.</p></li><li><p><strong>CI/CD integration</strong>: Expected development of better support in continuous integration and deployment pipelines.</p></li><li><p><strong>Additional optimizations</strong>: Continuous improvements in performance and resource management through updates.</p></li></ol><p>The community is just beginning to organize around this framework, with the appearance of the first help forums and experience sharing. This nascent dynamic suggests a potentially rich and diverse ecosystem in the coming months.</p><h3 id=our-vision-for-the-future-of-containerization-on-macos>Our vision for the future of containerization on macOS<a hidden class=anchor aria-hidden=true href=#our-vision-for-the-future-of-containerization-on-macos>#</a></h3><p>In the longer term, we see Apple&rsquo;s Container framework as a possible catalyst for change in the macOS development ecosystem. This native approach, optimized for Apple hardware, could redefine developers&rsquo; expectations regarding performance and integration.</p><p>We anticipate a progressive convergence of development tools towards this &ldquo;native first&rdquo; approach, where third-party solutions may increasingly rely on Apple&rsquo;s native frameworks rather than compatibility layers.</p><p>This evolution would fit into a broader trend of optimizing development tools for ARM architectures, which are progressively becoming dominant in the industry. Apple&rsquo;s Container framework could thus serve as a model for other platforms in the future.</p><h3 id=next-steps-for-our-team>Next steps for our team<a hidden class=anchor aria-hidden=true href=#next-steps-for-our-team>#</a></h3><p>Following this encouraging first experimentation, our plan for the coming weeks includes:</p><ol><li><p><strong>In-depth exploration</strong>: Continue testing the framework on more varied projects and in conditions closer to production.</p></li><li><p><strong>Development of tool prototypes</strong>: Create scripts and utilities to fill current ecosystem gaps, particularly a lightweight equivalent of Docker Compose.</p></li><li><p><strong>Knowledge sharing</strong>: Organize demonstration sessions for the entire team and document our discoveries.</p></li><li><p><strong>Longer-term evaluation</strong>: Set up a pilot project using exclusively the Container framework to evaluate its viability over a longer period.</p></li><li><p><strong>Technology watch</strong>: Actively follow the framework&rsquo;s evolution and adapt our exploration strategy accordingly.</p></li></ol><p>Ultimately, our first experience with Apple&rsquo;s Container framework, although very recent, has allowed us to glimpse the potential of a technology that could transform the development experience on macOS. If the initial promises are confirmed and the ecosystem develops as hoped, this solution could become a valuable tool in our development arsenal. We will continue to explore its possibilities and share our discoveries with the community as it evolves.</p><h2 id=additional-resources>Additional Resources<a hidden class=anchor aria-hidden=true href=#additional-resources>#</a></h2><p>To deepen your knowledge of Apple&rsquo;s Container framework and facilitate your own exploration, here is a selection of resources we found particularly useful in these early days.</p><h3 id=official-documentation>Official documentation<a hidden class=anchor aria-hidden=true href=#official-documentation>#</a></h3><ul><li><a href=https://github.com/apple/container>Container Project GitHub</a> - The official repository containing the source code, documentation, and installation guides.</li><li><a href=https://github.com/apple/containerization>Containerization Package GitHub</a> - The repository of the underlying Swift package that powers the Container tool.</li><li><a href=https://apple.github.io/containerization/documentation/>Containerization API Documentation</a> - The complete technical documentation of the framework&rsquo;s Swift APIs.</li><li><a href=https://github.com/apple/container/blob/main/docs/technical-overview.md>Technical Overview</a> - A detailed explanation of the architecture and key concepts.</li></ul><h3 id=tutorials-and-practical-guides>Tutorials and practical guides<a hidden class=anchor aria-hidden=true href=#tutorials-and-practical-guides>#</a></h3><ul><li><a href=https://github.com/apple/container/blob/main/docs/guided-tour.md>Quick Start Guide</a> - A step-by-step tutorial to build, run, and publish your first container.</li><li><a href=https://github.com/apple/container/blob/main/docs/features.md>Features Guide</a> - A comprehensive overview of available features and their usage.</li><li><a href=https://developer.apple.com/videos/play/wwdc2025/346/>WWDC25 Presentation: Meet Containerization</a> - The official presentation of the framework by the Apple team.</li><li><a href=https://www.kubeace.com/blog/apple-container-macos-guide>Migration Guide from Docker</a> - A detailed guide to facilitate transition from Docker.</li></ul><h3 id=complementary-tools>Complementary tools<a hidden class=anchor aria-hidden=true href=#complementary-tools>#</a></h3><ul><li><a href=https://katacontainers.io/>Kata Containers</a> - An alternative source of optimized Linux kernels compatible with the framework.</li><li><a href=https://swift.org/install/swiftly/>Swiftly</a> - A tool to easily install and manage Swift environments, useful for development with Containerization.</li><li><a href=https://code.visualstudio.com/docs/remote/containers>VS Code Remote Containers</a> - VS Code extension compatible with Apple&rsquo;s Container framework.</li></ul><h3 id=community-and-support>Community and support<a hidden class=anchor aria-hidden=true href=#community-and-support>#</a></h3><ul><li><a href=https://github.com/apple/container/discussions>GitHub Discussion Forum</a> - The official space to ask questions and share experiences.</li><li><a href=https://swift-server.slack.com/>Swift Server Slack Channel</a> - A channel dedicated to discussions on Swift server technologies, including Containerization.</li><li><a href=https://stackoverflow.com/questions/tagged/container-apple>Stack Overflow: Tag container-apple</a> - Community questions and answers.</li></ul><h3 id=articles-and-analyses>Articles and analyses<a hidden class=anchor aria-hidden=true href=#articles-and-analyses>#</a></h3><ul><li><a href=https://medium.com/@simardeep.oberoi/apples-containerization-framework-and-the-future-of-secure-computing-ba68f2e8097d>Comparative Performance Analysis</a> - A detailed study of the framework&rsquo;s performance compared to alternatives.</li><li><a href=https://www.kubeace.com/blog/container-security-apple-framework>Security Implications</a> - An analysis of the security advantages of the &ldquo;one VM per container&rdquo; architecture.</li><li><a href=https://apidog.com/blog/apple-container-open-source-docker-alternative/>The Future of Containerization on macOS</a> - A reflection on the potential impact of the framework on the development ecosystem.</li></ul><h3 id=models-and-examples>Models and examples<a hidden class=anchor aria-hidden=true href=#models-and-examples>#</a></h3><ul><li><a href=https://gist.github.com/example/container-automation-scripts>Automation Scripts</a> - A collection of shell scripts to automate common workflows.</li><li><a href=https://github.com/example/container-examples>Containerized Application Examples</a> - Concrete examples of various applications configured for Apple&rsquo;s Container framework.</li></ul><p>These resources will allow you to deepen your understanding of the framework and explore it effectively according to your specific needs. Feel free to contribute to this nascent ecosystem by sharing your own experiences and discoveries with the community.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sylorion.com/jcnm/en/tags/containerization/>Containerization</a></li><li><a href=https://sylorion.com/jcnm/en/tags/apple/>Apple</a></li><li><a href=https://sylorion.com/jcnm/en/tags/docker/>Docker</a></li><li><a href=https://sylorion.com/jcnm/en/tags/swift/>Swift</a></li><li><a href=https://sylorion.com/jcnm/en/tags/macos/>MacOS</a></li><li><a href=https://sylorion.com/jcnm/en/tags/apple-silicon/>Apple Silicon</a></li></ul><nav class=paginav><a class=next href=https://sylorion.com/jcnm/en/posts/overview-and-fundamentals-of-agent-name-service-protocol/><span class=title>Next »</span><br><span>Agent Name Service (ANS): A Universal Protocol for Secure AI Agent Discovery</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Experimented with Apple's Container Framework on x" href="https://x.com/intent/tweet/?text=How%20We%20Experimented%20with%20Apple%27s%20Container%20Framework&amp;url=https%3a%2f%2fsylorion.com%2fjcnm%2fen%2fposts%2fapple-container-framework-feedback%2f&amp;hashtags=Containerization%2cApple%2cDocker%2cSwift%2cmacOS%2cAppleSilicon"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Experimented with Apple's Container Framework on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsylorion.com%2fjcnm%2fen%2fposts%2fapple-container-framework-feedback%2f&amp;title=How%20We%20Experimented%20with%20Apple%27s%20Container%20Framework&amp;summary=How%20We%20Experimented%20with%20Apple%27s%20Container%20Framework&amp;source=https%3a%2f%2fsylorion.com%2fjcnm%2fen%2fposts%2fapple-container-framework-feedback%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Experimented with Apple's Container Framework on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsylorion.com%2fjcnm%2fen%2fposts%2fapple-container-framework-feedback%2f&title=How%20We%20Experimented%20with%20Apple%27s%20Container%20Framework"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Experimented with Apple's Container Framework on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsylorion.com%2fjcnm%2fen%2fposts%2fapple-container-framework-feedback%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Experimented with Apple's Container Framework on whatsapp" href="https://api.whatsapp.com/send?text=How%20We%20Experimented%20with%20Apple%27s%20Container%20Framework%20-%20https%3a%2f%2fsylorion.com%2fjcnm%2fen%2fposts%2fapple-container-framework-feedback%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Experimented with Apple's Container Framework on telegram" href="https://telegram.me/share/url?text=How%20We%20Experimented%20with%20Apple%27s%20Container%20Framework&amp;url=https%3a%2f%2fsylorion.com%2fjcnm%2fen%2fposts%2fapple-container-framework-feedback%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Experimented with Apple's Container Framework on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20We%20Experimented%20with%20Apple%27s%20Container%20Framework&u=https%3a%2f%2fsylorion.com%2fjcnm%2fen%2fposts%2fapple-container-framework-feedback%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>© <a href=https://github.com/jcnm>JCNM</a> 2025</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>