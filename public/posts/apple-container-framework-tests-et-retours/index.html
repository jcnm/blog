<!doctype html><html lang=fr dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Comment nous avons expérimenté le framework Container d'Apple | JCNM</title>
<meta name=keywords content="Container Apple,Containerization,Docker alternative,macOS conteneurs,Apple Silicon développement,VM légères,OCI,Virtualisation macOS"><meta name=description content="Découvrez notre première expérience avec le framework Container d'Apple, une solution native de conteneurisation optimisée pour macOS et Apple Silicon, annoncée il y a seulement quelques jours."><meta name=author content="Services CEO DevOps Team"><link rel=canonical href=https://sylorion.com/jcnm/posts/apple-container-framework-tests-et-retours/><meta name=google-site-verification content="G-T88E0SY453"><link crossorigin=anonymous href=/jcnm/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://sylorion.com/jcnm/images/icon32x32.png><link rel=icon type=image/png sizes=16x16 href=https://sylorion.com/jcnm/images/icon16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sylorion.com/jcnm/images/icon32x32.png><link rel=apple-touch-icon href=https://sylorion.com/jcnm/images/icon152x152.png><link rel=mask-icon href=https://sylorion.com/jcnm/images/icon180x180.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sylorion.com/jcnm/en/posts/apple-container-framework-feedback/><link rel=alternate hreflang=fr href=https://sylorion.com/jcnm/posts/apple-container-framework-tests-et-retours/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-T88E0SY453"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-T88E0SY453")</script><meta property="og:url" content="https://sylorion.com/jcnm/posts/apple-container-framework-tests-et-retours/"><meta property="og:site_name" content="JCNM"><meta property="og:title" content="Comment nous avons expérimenté le framework Container d'Apple"><meta property="og:description" content="Découvrez notre première expérience avec le framework Container d'Apple, une solution native de conteneurisation optimisée pour macOS et Apple Silicon, annoncée il y a seulement quelques jours."><meta property="og:locale" content="fr-FR"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-11T05:25:00+00:00"><meta property="article:modified_time" content="2025-06-11T05:25:00+00:00"><meta property="article:tag" content="Conteneurisation"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Docker"><meta property="article:tag" content="Swift"><meta property="article:tag" content="MacOS"><meta property="article:tag" content="Apple Silicon"><meta property="og:image" content="https://sylorion.com/jcnm/images/apple_container_architecture.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sylorion.com/jcnm/images/apple_container_architecture.png"><meta name=twitter:title content="Comment nous avons expérimenté le framework Container d'Apple"><meta name=twitter:description content="Découvrez notre première expérience avec le framework Container d'Apple, une solution native de conteneurisation optimisée pour macOS et Apple Silicon, annoncée il y a seulement quelques jours."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sylorion.com/jcnm/posts/"},{"@type":"ListItem","position":2,"name":"Comment nous avons expérimenté le framework Container d'Apple","item":"https://sylorion.com/jcnm/posts/apple-container-framework-tests-et-retours/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Comment nous avons expérimenté le framework Container d'Apple","name":"Comment nous avons expérimenté le framework Container d\u0027Apple","description":"Découvrez notre première expérience avec le framework Container d'Apple, une solution native de conteneurisation optimisée pour macOS et Apple Silicon, annoncée il y a seulement quelques jours.","keywords":["Container Apple","Containerization","Docker alternative","macOS conteneurs","Apple Silicon développement","VM légères","OCI","Virtualisation macOS"],"articleBody":"Introduction (Le “Pourquoi”) Dans le monde du développement logiciel moderne, la conteneurisation est devenue un pilier incontournable de nos infrastructures. Elle nous permet d’encapsuler nos applications et leurs dépendances dans des environnements isolés, garantissant ainsi une cohérence entre les différentes étapes du cycle de développement. Cependant, pour les équipes travaillant sur macOS, et particulièrement sur les Mac équipés de puces Apple Silicon (M1/M2/M3/M4), cette approche s’accompagne souvent de compromis significatifs.\nDepuis notre migration vers les Mac Apple Silicon il y a deux ans, notre équipe de développement a régulièrement rencontré des défis avec les solutions de conteneurisation traditionnelles :\nDes temps de démarrage lents qui ralentissent nos cycles de développement Une consommation excessive de ressources (mémoire et CPU) par Docker Desktop Des problèmes de compatibilité avec certaines architectures de conteneurs Une intégration parfois laborieuse avec l’écosystème natif de macOS Des performances sous-optimales pour les charges de travail intensives Ces limitations ont un impact direct sur notre productivité quotidienne. Un développeur qui attend plusieurs secondes (voire dizaines de secondes) à chaque démarrage de conteneur peut perdre un temps précieux sur une journée complète. De même, un ordinateur dont les ressources sont monopolisées par l’infrastructure de conteneurisation devient moins réactif pour d’autres tâches essentielles.\nC’est dans ce contexte que l’annonce très récente par Apple de son framework Container a immédiatement attiré notre attention. Promettant une approche native, optimisée pour Apple Silicon et intégrée harmonieusement à macOS, cette nouvelle solution semblait répondre précisément aux défis que nous rencontrions. Mais au-delà des promesses marketing, nous voulions évaluer concrètement ce que ce framework pouvait apporter à notre workflow quotidien.\nNotre équipe a donc décidé d’explorer en profondeur le framework Container d’Apple dès son annonce il y a seulement quelques jours, de le comparer objectivement à nos solutions actuelles, et d’évaluer son potentiel pour transformer notre environnement de développement. Cet article partage notre première expérience, nos découvertes initiales et nos recommandations préliminaires pour les équipes qui envisagent d’explorer cette nouvelle technologie.\nContexte (Le “Quoi”) Le framework Container d’Apple représente une approche fondamentalement nouvelle de la conteneurisation sur macOS. Contrairement à une simple alternative à Docker, il s’agit d’une solution native conçue spécifiquement pour l’écosystème Apple, et particulièrement optimisée pour les puces Apple Silicon.\nQu’est-ce que le framework Container d’Apple ? À sa base, le framework Container d’Apple est composé de deux éléments principaux :\nL’outil container : Une interface en ligne de commande (CLI) écrite en Swift qui permet de créer et d’exécuter des conteneurs Linux sur macOS. Cet outil est le point d’entrée principal pour les développeurs.\nLe package Containerization : Une bibliothèque Swift sous-jacente qui fournit les API nécessaires pour gérer les conteneurs, les images, et les processus. Ce package est le moteur qui alimente l’outil container.\nEnsemble, ces composants offrent une solution complète pour exécuter des conteneurs Linux directement sur macOS, sans nécessiter de couche d’émulation lourde ou de machine virtuelle partagée.\nUne architecture repensée pour la performance Ce qui distingue fondamentalement le framework Container d’Apple des solutions existantes est son architecture technique :\nUne VM par conteneur : Chaque conteneur s’exécute dans sa propre machine virtuelle légère et optimisée, garantissant une isolation complète. Noyau Linux optimisé : Un noyau Linux minimal et optimisé permet des temps de démarrage inférieurs à une seconde. Intégration native avec Virtualization.framework : Utilisation directe des API de virtualisation d’Apple pour des performances maximales. Système d’init léger (vminitd) : Un système d’initialisation minimaliste qui démarre rapidement et consomme peu de ressources. Support de Rosetta 2 : Capacité à exécuter des conteneurs x86_64 sur Apple Silicon via la technologie de traduction d’Apple. Cette approche “une VM par conteneur” offre non seulement des avantages en termes de performance, mais aussi une sécurité renforcée. En cas de compromission d’un conteneur, l’attaquant reste confiné dans une VM isolée, sans accès aux autres conteneurs.\nCompatibilité avec l’écosystème existant Malgré son approche innovante, le framework Container d’Apple n’isole pas les développeurs de l’écosystème de conteneurisation existant :\nConformité OCI : Compatibilité totale avec les images au format Open Container Initiative (OCI), le standard de l’industrie. Registres standards : Capacité à récupérer et publier des images depuis/vers Docker Hub, GitHub Container Registry, et autres registres standards. Syntaxe familière : Commandes similaires à Docker pour faciliter la transition des équipes. Support multi-architecture : Gestion native des images ARM64 et, via Rosetta 2, des images x86_64. Cette compatibilité permet aux équipes d’explorer le framework Container d’Apple sans rupture majeure dans leurs workflows existants, tout en bénéficiant immédiatement des gains de performance.\nPositionnement par rapport aux alternatives Pour situer clairement cette solution dans le paysage technologique actuel :\nAspect Docker Desktop Podman Framework Container d’Apple Architecture VM Linux partagée Daemonless, rootless VM dédiée par conteneur Performance Modérée Bonne Excellente sur Apple Silicon Empreinte mémoire Élevée (500MB-2GB) Moyenne Faible (\u003c200MB) Temps de démarrage 3-5 secondes 2-3 secondes \u003c1 seconde Isolation Conteneurs partagés Conteneurs isolés VM isolées Intégration macOS Via couche de compatibilité Via couche de compatibilité Native Maturité Très mature Mature Très récent (quelques jours) Le framework Container d’Apple se positionne donc comme une solution hautement optimisée pour les développeurs sur macOS, particulièrement ceux utilisant des machines Apple Silicon, avec un accent mis sur la performance, la sécurité et l’intégration native.\nDémarche (Le “Comment”) Après avoir découvert le framework Container d’Apple lors de son annonce il y a quelques jours, nous avons immédiatement mis en place une démarche méthodique pour l’évaluer et explorer son potentiel pour notre workflow. Voici comment nous avons procédé, étape par étape, dans cette première phase d’expérimentation.\nInstallation et configuration initiale Notre première étape a été d’installer l’outil container sur nos machines de développement. Le processus s’est révélé remarquablement simple :\nTéléchargement du package d’installation : Nous avons récupéré le dernier package signé (.pkg) depuis la page des releases GitHub d’Apple, publiée tout récemment.\nInstallation standard : Un simple double-clic sur le package et l’entrée du mot de passe administrateur ont suffi pour installer l’outil dans /usr/local/.\nDémarrage du service : Dans le terminal, nous avons initialisé le service avec la commande :\n1 container system start Cette commande a automatiquement proposé de télécharger un noyau Linux optimisé, que nous avons accepté.\nVérification de l’installation : Nous avons confirmé le bon fonctionnement avec :\n1 2 container --version container ls -a Contrairement à d’autres solutions qui nécessitent des configurations complexes ou des dépendances multiples, l’installation s’est déroulée en moins de 5 minutes par poste, sans aucun problème de compatibilité sur nos Mac M1 et M2.\nPremiers pas avec le framework Pour nous familiariser avec l’outil, nous avons commencé par des opérations simples :\nRécupération d’images : Nous avons testé la récupération d’images depuis Docker Hub :\n1 2 container image pull nginx:alpine container image pull python:3.9 Exécution de conteneurs basiques : Nous avons lancé des conteneurs simples pour vérifier le fonctionnement :\n1 container run --detach --name webserver --publish 8080:80 nginx:alpine Interaction avec les conteneurs : Nous avons testé les commandes d’interaction :\n1 2 3 container ps container logs webserver container exec -it webserver sh Ces premiers tests ont immédiatement mis en évidence la rapidité d’exécution du framework. Le démarrage des conteneurs était quasi instantané, et l’utilisation des ressources système restait minimale même avec plusieurs conteneurs en cours d’exécution.\nExploration des commandes équivalentes à Docker Pour faciliter notre expérimentation, nous avons créé un tableau d’équivalence des commandes les plus utilisées :\nAction Commande Docker Commande Container Lister les conteneurs docker ps container ps Lister toutes les images docker images container image list Exécuter un conteneur docker run container run Arrêter un conteneur docker stop container stop Supprimer un conteneur docker rm container rm Afficher les logs docker logs container logs Exécuter une commande docker exec container exec Cette similitude syntaxique a considérablement facilité nos premiers pas avec l’outil. La plupart des développeurs ont pu transposer leurs habitudes sans effort d’apprentissage majeur. Vous avez aussi des options avancés type container run -e VAR=value nginx etc nous vous laissons le plaisir d’explorer.\nConfiguration réseau et optimisations La gestion réseau étant un aspect crucial de notre infrastructure de développement, nous avons exploré les capacités du framework dans ce domaine :\nConfiguration réseau de base : Sur macOS 15, nous avons utilisé l’approche traditionnelle de publication de ports :\n1 container run --detach --name api --publish 3000:3000 notre-api Réseau avancé sur macOS 26 Beta : Sur les machines de test avec macOS 26 Beta, nous avons exploré les fonctionnalités réseau avancées :\n1 2 3 4 5 6 # Création d'un réseau dédié container network create app-network # Déploiement de services interconnectés container run --detach --name db --network app-network mongo container run --detach --name api --network app-network notre-api Cette configuration a permis une communication directe entre conteneurs sans nécessiter de publication de ports, simplifiant considérablement notre architecture.\nExploration des volumes : Nous avons testé l’utilisation des volumes pour le développement local :\n1 container run --volume /Users/dev/projet:/app notre-image Intégration dans notre environnement de test Pour cette phase d’expérimentation initiale, nous avons créé un environnement de test représentatif :\nScripts d’automatisation : Nous avons créé des scripts shell pour standardiser les opérations courantes :\n1 2 3 4 5 6 #!/bin/bash # start-dev-env.sh container system start container run --detach --name redis redis:alpine container run --detach --name postgres --env POSTGRES_PASSWORD=dev postgres:13 container run --detach --name app --publish 3000:3000 --volume $(pwd):/app notre-app Tests avec VS Code : Nous avons vérifié la compatibilité avec VS Code via l’extension Remote Containers, qui s’est avérée fonctionnelle avec le framework Container d’Apple.\nDocumentation des observations : Nous avons soigneusement documenté nos découvertes et créé un guide d’expérimentation pour l’ensemble de l’équipe.\nCette démarche exploratoire nous a permis d’évaluer rapidement le framework Container d’Apple dans les jours suivant son annonce, et de recueillir des premières impressions sur son potentiel pour notre environnement de développement.\nRésultats et Observations (Le “Qu’est-ce qui s’est passé”) Après quelques jours d’expérimentation intensive du framework Container d’Apple depuis son annonce, nous avons recueilli des données préliminaires qui permettent d’évaluer objectivement son potentiel pour notre environnement de développement.\nPerformances comparées La première différence frappante concerne les performances. Nous avons mesuré systématiquement les métriques clés en comparant notre configuration habituelle (Docker Desktop) avec le framework Container d’Apple :\nMétrique Docker Desktop Framework Container d’Apple Amélioration Temps de démarrage à froid 3.8 secondes 0.7 seconde 81% Utilisation mémoire au repos 1.2 GB 180 MB 85% Utilisation CPU au repos 8-12% 1-2% ~85% Temps de build d’image 45 secondes 38 secondes 16% Temps de pull d’image Référence 20% plus rapide 20% Ces chiffres préliminaires sont impressionnants : le framework Container d’Apple offre des gains de performance substantiels sur tous les aspects mesurés. L’impact le plus significatif concerne le temps de démarrage des conteneurs et l’utilisation des ressources système, deux points qui affectent directement l’expérience quotidienne des développeurs.\nPour illustrer concrètement : un développeur qui lance et arrête 20 conteneurs par jour pourrait économiser environ 62 secondes d’attente quotidienne. Sur un mois de travail, cela représenterait plus de 20 minutes récupérées, sans compter les bénéfices indirects d’un système moins sollicité et donc plus réactif.\nCompatibilité avec nos projets existants Un aspect crucial de notre évaluation concernait la compatibilité avec notre écosystème existant. Voici nos premières observations :\nImages Docker standard : 100% de nos images Docker Hub habituelles fonctionnent sans modification. Images multi-architecture : Excellente gestion des images ARM64 natives et bonne compatibilité avec les images x86_64 via Rosetta 2. Volumes et persistance : Fonctionnement identique à Docker pour le montage de volumes locaux. Réseaux : Fonctionnalités de base équivalentes sur macOS 15, fonctionnalités avancées prometteuses sur macOS 26 Beta. Outils de développement : Compatibilité confirmée avec VS Code, JetBrains et autres IDE via leurs extensions de développement à distance. Nous avons testé notre stack de développement typique, qui comprend :\nUne base de données PostgreSQL Un cache Redis Un serveur d’API Node.js Un frontend React Un service de traitement en Python Tous ces composants ont fonctionné sans modification majeure dans notre environnement de test, nécessitant uniquement l’adaptation des commandes de lancement pour utiliser la syntaxe du framework Container d’Apple.\nAvantages observés Au-delà des métriques pures, plusieurs avantages qualitatifs ont émergé de nos premiers tests :\nStabilité prometteuse : Nous n’avons rencontré aucun incident majeur lié à l’infrastructure de conteneurisation (plantages, problèmes de réseau, etc.) durant notre période d’expérimentation.\nSécurité renforcée : L’architecture “une VM par conteneur” offre théoriquement une isolation plus forte, particulièrement appréciable pour les tests de code potentiellement risqué.\nIntégration native : L’intégration avec macOS semble plus fluide, notamment pour la gestion des credentials via le Trousseau d’accès et l’utilisation des ressources système.\nSimplicité d’utilisation : L’interface en ligne de commande est intuitive et cohérente, avec une courbe d’apprentissage très faible pour notre équipe.\nRéactivité du système : Les développeurs rapportent une meilleure réactivité globale de leurs machines durant les tests, même avec plusieurs conteneurs en cours d’exécution.\nLimitations et défis rencontrés Notre expérience n’a pas été sans obstacles. Voici les principales limitations que nous avons identifiées dans cette phase initiale :\nMaturité de l’écosystème : En tant que projet extrêmement récent, le framework Container d’Apple ne dispose pas encore d’un écosystème aussi riche que Docker (interfaces graphiques, outils de monitoring, etc.).\nCompatibilité macOS : Les fonctionnalités réseau avancées nécessitent macOS 26 Beta, ce qui limite leur utilisation dans un environnement de production.\nDocumentation en développement : La documentation, bien que solide pour un projet si récent, est encore en développement et certains cas d’usage avancés sont moins bien couverts.\nAbsence de Compose : L’équivalent de Docker Compose pour orchestrer plusieurs conteneurs n’est pas encore disponible nativement, nécessitant des scripts personnalisés.\nLimitations de build : Le système de build d’images semble moins flexible que Dockerfile pour certains scénarios complexes.\nRetours initiaux de l’équipe de développement Nous avons recueilli les premières impressions de notre équipe après ces quelques jours d’expérimentation :\n85% des développeurs sont enthousiastes et voient un potentiel significatif dans cette solution 10% sont neutres, trouvant la solution prometteuse mais préférant attendre sa maturation 5% sont plus réservés, principalement en raison de l’écosystème encore limité Les commentaires positifs mentionnent principalement la rapidité, la légèreté et la stabilité. Les réticences concernent principalement la jeunesse du projet et l’incertitude quant à son évolution future.\nUn développeur senior a résumé le sentiment général : “C’est comme découvrir une voiture conçue spécifiquement pour nos routes. Tout semble plus naturel, plus rapide, et mieux intégré à notre environnement. Mais il faudra voir comment elle se comporte sur le long terme.”\nLeçons Apprises et Recommandations (Le “Et alors ?”) Notre expérimentation initiale avec le framework Container d’Apple nous a permis de dégager plusieurs enseignements préliminaires et de formuler des recommandations pour les équipes qui envisagent d’explorer cette nouvelle technologie.\nCas d’usage potentiellement idéaux pour le framework Container d’Apple D’après nos premiers tests, nous avons identifié les scénarios où ce framework pourrait particulièrement exceller :\nEnvironnements de développement sur Mac Apple Silicon : C’est le cas d’usage par excellence, où les gains de performance semblent les plus significatifs.\nÉquipes ayant des contraintes de ressources : Pour les développeurs travaillant sur des machines avec des ressources limitées (8GB de RAM par exemple), la légèreté du framework pourrait faire une différence considérable.\nProjets nécessitant des démarrages fréquents de conteneurs : Les workflows impliquant de nombreux cycles démarrage/arrêt bénéficieraient énormément des temps de démarrage ultra-rapides.\nApplications nécessitant une isolation renforcée : Les projets manipulant des données sensibles ou exécutant du code non vérifié pourraient profiter de l’isolation VM par conteneur.\nEnvironnements de développement multi-conteneurs : Sur macOS 26 Beta, la gestion réseau avancée semble prometteuse pour simplifier les architectures multi-services.\nEn revanche, certains cas d’usage semblent pour l’instant mieux servis par des solutions alternatives :\nEnvironnements nécessitant Docker Compose ou des orchestrateurs complexes Workflows dépendant fortement d’outils graphiques de gestion de conteneurs Équipes utilisant des Mac Intel (non supportés par le framework) Projets nécessitant des fonctionnalités Docker avancées non encore implémentées Bonnes pratiques identifiées Notre expérience initiale nous a permis d’établir plusieurs bonnes pratiques pour tirer le meilleur parti du framework Container d’Apple :\nPrivilégier les images ARM64 natives : Bien que Rosetta 2 permette d’exécuter des images x86_64, les performances semblent nettement meilleures avec des images compilées pour ARM64.\nUtiliser des scripts d’automatisation : Créer des scripts shell pour remplacer les fonctionnalités de Docker Compose simplifie considérablement la gestion d’environnements multi-conteneurs.\nOptimiser les volumes : Limiter le nombre et la taille des volumes montés semble améliorer les performances, particulièrement pour les applications manipulant de nombreux petits fichiers.\nAdopter une approche “stateless” : Concevoir les conteneurs pour être éphémères et sans état facilite leur gestion avec le framework Container d’Apple.\nStandardiser les commandes : Créer des alias ou des fonctions shell pour uniformiser les commandes entre Docker et le framework Container simplifie l’expérimentation.\nSuivre activement les mises à jour : Le framework étant en développement très actif, des améliorations significatives sont susceptibles d’être publiées régulièrement.\nConseils pour une exploration efficace Pour les équipes envisageant d’explorer le framework Container d’Apple, voici notre feuille de route recommandée :\nPhase de découverte : Commencer par installer et tester l’outil sur un projet non critique pour évaluer la compatibilité et les performances.\nApproche progressive : Expérimenter projet par projet plutôt que de basculer toute l’infrastructure d’un coup.\nDocumentation des équivalences : Créer un guide interne des équivalences entre les commandes Docker et Container.\nPartage d’expérience : Organiser des sessions de démonstration courtes (30-60 minutes) pour présenter les nouvelles possibilités à l’équipe.\nEnvironnement parallèle : Maintenir les deux solutions en parallèle pendant la phase d’exploration.\nFeedback continu : Mettre en place un canal dédié pour recueillir les retours d’expérience et documenter les découvertes.\nConsidérations pour différents types d’équipes L’exploration du framework Container d’Apple doit être adaptée au contexte spécifique de chaque équipe :\nPour les petites équipes (1-5 développeurs) :\nL’expérimentation peut être rapide et informelle Les gains en performance sont immédiatement perceptibles L’absence de certains outils graphiques peut être compensée par des scripts personnalisés Pour les équipes moyennes (5-15 développeurs) :\nUne approche plus structurée est recommandée Désigner un “explorateur” responsable de l’évaluation et du partage des découvertes Documenter formellement les observations et les cas d’usage testés Prévoir une phase d’exploration plus méthodique Pour les grandes équipes (15+ développeurs) :\nCréer un groupe d’exploration dédié pour tester et documenter les possibilités Développer des prototypes d’outils internes pour combler les lacunes de l’écosystème Mettre en place une évaluation formelle Envisager des tests limités dans des environnements non critiques Prévoir une exploration par phases avec des objectifs clairs Impact potentiel sur la productivité et la satisfaction Au-delà des aspects techniques, nous avons observé des impacts potentiels sur des facteurs plus subjectifs mais tout aussi importants :\nRéduction de la frustration : Les temps d’attente réduits et la stabilité apparente pourraient diminuer les interruptions du flux de travail. Satisfaction accrue : Les développeurs semblent apprécier de travailler avec des outils optimisés pour leur matériel. Sentiment d’appartenance : L’utilisation d’une technologie Apple native sur du matériel Apple crée une expérience plus cohérente et intégrée. Réduction du “tax mental” : Moins de ressources cognitives semblent consacrées à la gestion de l’infrastructure, permettant une meilleure concentration sur le code. Ces facteurs, bien que difficiles à quantifier dans cette phase préliminaire, pourraient contribuer significativement à l’amélioration globale de l’expérience de développement si le framework tient ses promesses sur le long terme.\nConclusion et Perspectives Notre exploration initiale du framework Container d’Apple, quelques jours seulement après son annonce, nous a permis d’entrevoir le potentiel de cette nouvelle approche de la conteneurisation sur macOS. Ce qui a commencé comme une simple curiosité technique s’est rapidement transformé en une évaluation prometteuse, avec des résultats préliminaires encourageants.\nSynthèse des points clés Le framework Container d’Apple se distingue par plusieurs caractéristiques fondamentales :\nPerformance native sur Apple Silicon : Des temps de démarrage inférieurs à une seconde et une empreinte mémoire réduite de 85% par rapport à Docker Desktop dans nos tests initiaux. Architecture sécurisée : L’isolation par VM offre théoriquement une sécurité renforcée sans compromettre les performances. Compatibilité OCI : L’intégration transparente avec l’écosystème de conteneurs existant facilite l’expérimentation. Intégration macOS : L’utilisation des technologies natives d’Apple (Virtualization.framework, Keychain, etc.) crée une expérience cohérente et optimisée. Ces avantages pourraient se traduire par une amélioration concrète de notre productivité quotidienne, avec moins d’interruptions, une meilleure stabilité, et une utilisation plus efficace des ressources de nos machines.\nÉvolution attendue du framework et de l’écosystème Le framework Container d’Apple étant un projet extrêmement récent, nous anticipons plusieurs évolutions significatives dans les mois à venir :\nMaturation de l’écosystème : Développement progressif d’outils complémentaires, d’interfaces graphiques, et d’intégrations avec les IDE populaires.\nAmélioration des fonctionnalités réseau : Extension probable des capacités réseau avancées à macOS standard après la période beta.\nÉquivalent de Compose : Émergence possible d’une solution native ou tierce pour l’orchestration multi-conteneurs, comblant l’une des principales lacunes actuelles.\nIntégration CI/CD : Développement attendu d’une meilleure prise en charge dans les pipelines d’intégration et de déploiement continus.\nOptimisations supplémentaires : Améliorations continues des performances et de la gestion des ressources au fil des mises à jour.\nLa communauté commence tout juste à s’organiser autour de ce framework, avec l’apparition des premiers forums d’entraide et partages d’expérience. Cette dynamique naissante laisse présager un écosystème potentiellement riche et diversifié dans les mois à venir.\nNotre vision pour l’avenir de la conteneurisation sur macOS À plus long terme, nous voyons le framework Container d’Apple comme un possible catalyseur de changement dans l’écosystème de développement sur macOS. Cette approche native, optimisée pour le matériel Apple, pourrait redéfinir les attentes des développeurs en matière de performance et d’intégration.\nNous anticipons une convergence progressive des outils de développement vers cette approche “native first”, où les solutions tierces s’appuieront peut-être de plus en plus sur les frameworks natifs d’Apple plutôt que sur des couches de compatibilité.\nCette évolution s’inscrirait dans une tendance plus large d’optimisation des outils de développement pour les architectures ARM, qui deviennent progressivement dominantes dans l’industrie. Le framework Container d’Apple pourrait ainsi servir de modèle pour d’autres plateformes à l’avenir.\nProchaines étapes pour notre équipe Suite à cette première expérimentation encourageante, notre plan pour les prochaines semaines comprend :\nExploration approfondie : Continuer à tester le framework sur des projets plus variés et dans des conditions plus proches de la production.\nDéveloppement de prototypes d’outils : Créer des scripts et utilitaires pour combler les lacunes actuelles de l’écosystème, notamment un équivalent léger de Docker Compose.\nPartage de connaissances : Organiser des sessions de démonstration pour l’ensemble de l’équipe et documenter nos découvertes.\nÉvaluation à plus long terme : Mettre en place un projet pilote utilisant exclusivement le framework Container pour évaluer sa viabilité sur une période plus longue.\nVeille technologique : Suivre activement l’évolution du framework et adapter notre stratégie d’exploration en conséquence.\nEn définitive, notre première expérience avec le framework Container d’Apple, bien que très récente, nous a permis d’entrevoir le potentiel d’une technologie qui pourrait transformer l’expérience de développement sur macOS. Si les promesses initiales se confirment et que l’écosystème se développe comme espéré, cette solution pourrait devenir un outil précieux dans notre arsenal de développement. Nous continuerons à explorer ses possibilités et à partager nos découvertes avec la communauté au fil de son évolution.\nRessources complémentaires Pour approfondir votre connaissance du framework Container d’Apple et faciliter votre propre exploration, voici une sélection de ressources que nous avons trouvées particulièrement utiles dans ces premiers jours.\nDocumentation officielle GitHub du projet Container - Le dépôt officiel contenant le code source, la documentation et les guides d’installation. GitHub du package Containerization - Le dépôt du package Swift sous-jacent qui alimente l’outil Container. Documentation API de Containerization - La documentation technique complète des API Swift du framework. Vue d’ensemble technique - Une explication détaillée de l’architecture et des concepts clés. Tutoriels et guides pratiques Guide de démarrage rapide - Un tutoriel pas à pas pour construire, exécuter et publier votre premier conteneur. Guide des fonctionnalités - Un aperçu complet des fonctionnalités disponibles et de leur utilisation. Présentation WWDC25: Meet Containerization - La présentation officielle du framework par l’équipe Apple. Guide de migration depuis Docker - Un guide détaillé pour faciliter la transition depuis Docker. Outils complémentaires Kata Containers - Une source alternative de noyaux Linux optimisés compatibles avec le framework. Swiftly - Un outil pour installer et gérer facilement les environnements Swift, utile pour le développement avec Containerization. VS Code Remote Containers - Extension VS Code compatible avec le framework Container d’Apple. Communauté et support Forum de discussion GitHub - L’espace officiel pour poser des questions et partager des expériences. Canal Slack Swift Server - Un canal dédié aux discussions sur les technologies serveur Swift, incluant Containerization. Stack Overflow: Tag container-apple - Questions et réponses de la communauté. Articles et analyses Analyse comparative des performances - Une étude détaillée des performances du framework par rapport aux alternatives. Implications pour la sécurité - Une analyse des avantages en termes de sécurité de l’architecture “une VM par conteneur”. L’avenir de la conteneurisation sur macOS - Une réflexion sur l’impact potentiel du framework sur l’écosystème de développement. Modèles et exemples Scripts d’automatisation - Une collection de scripts shell pour automatiser les workflows courants. Exemples d’applications conteneurisées - Des exemples concrets d’applications diverses configurées pour le framework Container d’Apple. Ces ressources vous permettront d’approfondir votre compréhension du framework et de l’explorer efficacement selon vos besoins spécifiques. N’hésitez pas à contribuer à cet écosystème naissant en partageant vos propres expériences et découvertes avec la communauté.\n","wordCount":"4214","inLanguage":"fr","image":"https://sylorion.com/jcnm/images/apple_container_architecture.png","datePublished":"2025-06-11T05:25:00Z","dateModified":"2025-06-11T05:25:00Z","author":{"@type":"Person","name":"Services CEO DevOps Team"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sylorion.com/jcnm/posts/apple-container-framework-tests-et-retours/"},"publisher":{"@type":"Organization","name":"JCNM","logo":{"@type":"ImageObject","url":"https://sylorion.com/jcnm/images/icon32x32.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sylorion.com/jcnm/ accesskey=h title="JCNM (Alt + H)"><img src=https://sylorion.com/jcnm/images/icon.png alt aria-label=logo height=35>JCNM</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://sylorion.com/jcnm/en/ title="🇬🇧 English" aria-label="🇬🇧 English">En</a></li></ul></div></div><ul id=menu><li><a href=https://sylorion.com/jcnm/posts title=Postes><span>Postes</span></a></li><li><a href=https://sylorion.com/jcnm/categories title=Catégories><span>Catégories</span></a></li><li><a href=https://sylorion.com/jcnm/tags title=Tags><span>Tags</span></a></li><li><a href=https://sylorion.com/jcnm/contact title=Contacter><span>Contacter</span></a></li><li><a href=https://sylorion.com/jcnm/a-propos title="À propos"><span>À propos</span></a></li><li><a href=https://github.com/jcnm/blog title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sylorion.com/jcnm/>Accueil</a>&nbsp;»&nbsp;<a href=https://sylorion.com/jcnm/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Comment nous avons expérimenté le framework Container d'Apple</h1><div class=post-description>Découvrez notre première expérience avec le framework Container d'Apple, une solution native de conteneurisation optimisée pour macOS et Apple Silicon, annoncée il y a seulement quelques jours.</div><div class=post-meta><span title='2025-06-11 05:25:00 +0000 +0000'>juin 11, 2025</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;4214 mots&nbsp;·&nbsp;Services CEO DevOps Team&nbsp;|&nbsp;Traductions:<ul class=i18n_list><li><a href=https://sylorion.com/jcnm/en/posts/apple-container-framework-feedback/>En</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/jcnm/blog/tree/main/content/posts/apple-container-framework-tests-et-retours.md rel="noopener noreferrer" target=_blank>✍️</a></div></header><figure class=entry-cover><img loading=eager src=https://sylorion.com/jcnm/images/apple_container_architecture.png alt="architecture de container apple"></figure><div class=post-content><h2 id=introduction-le-pourquoi>Introduction (Le &ldquo;Pourquoi&rdquo;)<a hidden class=anchor aria-hidden=true href=#introduction-le-pourquoi>#</a></h2><p>Dans le monde du développement logiciel moderne, la conteneurisation est devenue un pilier incontournable de nos infrastructures. Elle nous permet d&rsquo;encapsuler nos applications et leurs dépendances dans des environnements isolés, garantissant ainsi une cohérence entre les différentes étapes du cycle de développement. Cependant, pour les équipes travaillant sur macOS, et particulièrement sur les Mac équipés de puces Apple Silicon (M1/M2/M3/M4), cette approche s&rsquo;accompagne souvent de compromis significatifs.</p><p>Depuis notre migration vers les Mac Apple Silicon il y a deux ans, notre équipe de développement a régulièrement rencontré des défis avec les solutions de conteneurisation traditionnelles :</p><ul><li>Des temps de démarrage lents qui ralentissent nos cycles de développement</li><li>Une consommation excessive de ressources (mémoire et CPU) par Docker Desktop</li><li>Des problèmes de compatibilité avec certaines architectures de conteneurs</li><li>Une intégration parfois laborieuse avec l&rsquo;écosystème natif de macOS</li><li>Des performances sous-optimales pour les charges de travail intensives</li></ul><p>Ces limitations ont un impact direct sur notre productivité quotidienne. Un développeur qui attend plusieurs secondes (voire dizaines de secondes) à chaque démarrage de conteneur peut perdre un temps précieux sur une journée complète. De même, un ordinateur dont les ressources sont monopolisées par l&rsquo;infrastructure de conteneurisation devient moins réactif pour d&rsquo;autres tâches essentielles.</p><p>C&rsquo;est dans ce contexte que l&rsquo;annonce très récente par Apple de son framework Container a immédiatement attiré notre attention. Promettant une approche native, optimisée pour Apple Silicon et intégrée harmonieusement à macOS, cette nouvelle solution semblait répondre précisément aux défis que nous rencontrions. Mais au-delà des promesses marketing, nous voulions évaluer concrètement ce que ce framework pouvait apporter à notre workflow quotidien.</p><p>Notre équipe a donc décidé d&rsquo;explorer en profondeur le framework Container d&rsquo;Apple dès son annonce il y a seulement quelques jours, de le comparer objectivement à nos solutions actuelles, et d&rsquo;évaluer son potentiel pour transformer notre environnement de développement. Cet article partage notre première expérience, nos découvertes initiales et nos recommandations préliminaires pour les équipes qui envisagent d&rsquo;explorer cette nouvelle technologie.</p><h2 id=contexte-le-quoi>Contexte (Le &ldquo;Quoi&rdquo;)<a hidden class=anchor aria-hidden=true href=#contexte-le-quoi>#</a></h2><p>Le framework Container d&rsquo;Apple représente une approche fondamentalement nouvelle de la conteneurisation sur macOS. Contrairement à une simple alternative à Docker, il s&rsquo;agit d&rsquo;une solution native conçue spécifiquement pour l&rsquo;écosystème Apple, et particulièrement optimisée pour les puces Apple Silicon.</p><h3 id=quest-ce-que-le-framework-container-dapple->Qu&rsquo;est-ce que le framework Container d&rsquo;Apple ?<a hidden class=anchor aria-hidden=true href=#quest-ce-que-le-framework-container-dapple->#</a></h3><p>À sa base, le framework Container d&rsquo;Apple est composé de deux éléments principaux :</p><ol><li><p><strong>L&rsquo;outil <code>container</code></strong> : Une interface en ligne de commande (CLI) écrite en Swift qui permet de créer et d&rsquo;exécuter des conteneurs Linux sur macOS. Cet outil est le point d&rsquo;entrée principal pour les développeurs.</p></li><li><p><strong>Le package Containerization</strong> : Une bibliothèque Swift sous-jacente qui fournit les API nécessaires pour gérer les conteneurs, les images, et les processus. Ce package est le moteur qui alimente l&rsquo;outil <code>container</code>.</p></li></ol><p>Ensemble, ces composants offrent une solution complète pour exécuter des conteneurs Linux directement sur macOS, sans nécessiter de couche d&rsquo;émulation lourde ou de machine virtuelle partagée.</p><h3 id=une-architecture-repensée-pour-la-performance>Une architecture repensée pour la performance<a hidden class=anchor aria-hidden=true href=#une-architecture-repensée-pour-la-performance>#</a></h3><p>Ce qui distingue fondamentalement le framework Container d&rsquo;Apple des solutions existantes est son architecture technique :</p><ul><li><strong>Une VM par conteneur</strong> : Chaque conteneur s&rsquo;exécute dans sa propre machine virtuelle légère et optimisée, garantissant une isolation complète.</li><li><strong>Noyau Linux optimisé</strong> : Un noyau Linux minimal et optimisé permet des temps de démarrage inférieurs à une seconde.</li><li><strong>Intégration native avec Virtualization.framework</strong> : Utilisation directe des API de virtualisation d&rsquo;Apple pour des performances maximales.</li><li><strong>Système d&rsquo;init léger (vminitd)</strong> : Un système d&rsquo;initialisation minimaliste qui démarre rapidement et consomme peu de ressources.</li><li><strong>Support de Rosetta 2</strong> : Capacité à exécuter des conteneurs x86_64 sur Apple Silicon via la technologie de traduction d&rsquo;Apple.</li></ul><p>Cette approche &ldquo;une VM par conteneur&rdquo; offre non seulement des avantages en termes de performance, mais aussi une sécurité renforcée. En cas de compromission d&rsquo;un conteneur, l&rsquo;attaquant reste confiné dans une VM isolée, sans accès aux autres conteneurs.</p><h3 id=compatibilité-avec-lécosystème-existant>Compatibilité avec l&rsquo;écosystème existant<a hidden class=anchor aria-hidden=true href=#compatibilité-avec-lécosystème-existant>#</a></h3><p>Malgré son approche innovante, le framework Container d&rsquo;Apple n&rsquo;isole pas les développeurs de l&rsquo;écosystème de conteneurisation existant :</p><ul><li><strong>Conformité OCI</strong> : Compatibilité totale avec les images au format Open Container Initiative (OCI), le standard de l&rsquo;industrie.</li><li><strong>Registres standards</strong> : Capacité à récupérer et publier des images depuis/vers Docker Hub, GitHub Container Registry, et autres registres standards.</li><li><strong>Syntaxe familière</strong> : Commandes similaires à Docker pour faciliter la transition des équipes.</li><li><strong>Support multi-architecture</strong> : Gestion native des images ARM64 et, via Rosetta 2, des images x86_64.</li></ul><p>Cette compatibilité permet aux équipes d&rsquo;explorer le framework Container d&rsquo;Apple sans rupture majeure dans leurs workflows existants, tout en bénéficiant immédiatement des gains de performance.</p><h3 id=positionnement-par-rapport-aux-alternatives>Positionnement par rapport aux alternatives<a hidden class=anchor aria-hidden=true href=#positionnement-par-rapport-aux-alternatives>#</a></h3><p>Pour situer clairement cette solution dans le paysage technologique actuel :</p><table><thead><tr><th>Aspect</th><th>Docker Desktop</th><th>Podman</th><th>Framework Container d&rsquo;Apple</th></tr></thead><tbody><tr><td><strong>Architecture</strong></td><td>VM Linux partagée</td><td>Daemonless, rootless</td><td>VM dédiée par conteneur</td></tr><tr><td><strong>Performance</strong></td><td>Modérée</td><td>Bonne</td><td>Excellente sur Apple Silicon</td></tr><tr><td><strong>Empreinte mémoire</strong></td><td>Élevée (500MB-2GB)</td><td>Moyenne</td><td>Faible (&lt;200MB)</td></tr><tr><td><strong>Temps de démarrage</strong></td><td>3-5 secondes</td><td>2-3 secondes</td><td>&lt;1 seconde</td></tr><tr><td><strong>Isolation</strong></td><td>Conteneurs partagés</td><td>Conteneurs isolés</td><td>VM isolées</td></tr><tr><td><strong>Intégration macOS</strong></td><td>Via couche de compatibilité</td><td>Via couche de compatibilité</td><td>Native</td></tr><tr><td><strong>Maturité</strong></td><td>Très mature</td><td>Mature</td><td>Très récent (quelques jours)</td></tr></tbody></table><p>Le framework Container d&rsquo;Apple se positionne donc comme une solution hautement optimisée pour les développeurs sur macOS, particulièrement ceux utilisant des machines Apple Silicon, avec un accent mis sur la performance, la sécurité et l&rsquo;intégration native.</p><h2 id=démarche-le-comment>Démarche (Le &ldquo;Comment&rdquo;)<a hidden class=anchor aria-hidden=true href=#démarche-le-comment>#</a></h2><p>Après avoir découvert le framework Container d&rsquo;Apple lors de son annonce il y a quelques jours, nous avons immédiatement mis en place une démarche méthodique pour l&rsquo;évaluer et explorer son potentiel pour notre workflow. Voici comment nous avons procédé, étape par étape, dans cette première phase d&rsquo;expérimentation.</p><h3 id=installation-et-configuration-initiale>Installation et configuration initiale<a hidden class=anchor aria-hidden=true href=#installation-et-configuration-initiale>#</a></h3><p>Notre première étape a été d&rsquo;installer l&rsquo;outil <code>container</code> sur nos machines de développement. Le processus s&rsquo;est révélé remarquablement simple :</p><ol><li><p><strong>Téléchargement du package d&rsquo;installation</strong> : Nous avons récupéré le dernier package signé (.pkg) depuis la page des releases GitHub d&rsquo;Apple, publiée tout récemment.</p></li><li><p><strong>Installation standard</strong> : Un simple double-clic sur le package et l&rsquo;entrée du mot de passe administrateur ont suffi pour installer l&rsquo;outil dans <code>/usr/local/</code>.</p></li><li><p><strong>Démarrage du service</strong> : Dans le terminal, nous avons initialisé le service avec la commande :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container system start
</span></span></code></pre></td></tr></table></div></div><p>Cette commande a automatiquement proposé de télécharger un noyau Linux optimisé, que nous avons accepté.</p></li><li><p><strong>Vérification de l&rsquo;installation</strong> : Nous avons confirmé le bon fonctionnement avec :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container --version
</span></span><span class=line><span class=cl>container ls -a
</span></span></code></pre></td></tr></table></div></div></li></ol><p>Contrairement à d&rsquo;autres solutions qui nécessitent des configurations complexes ou des dépendances multiples, l&rsquo;installation s&rsquo;est déroulée en moins de 5 minutes par poste, sans aucun problème de compatibilité sur nos Mac M1 et M2.</p><h3 id=premiers-pas-avec-le-framework>Premiers pas avec le framework<a hidden class=anchor aria-hidden=true href=#premiers-pas-avec-le-framework>#</a></h3><p>Pour nous familiariser avec l&rsquo;outil, nous avons commencé par des opérations simples :</p><ol><li><p><strong>Récupération d&rsquo;images</strong> : Nous avons testé la récupération d&rsquo;images depuis Docker Hub :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container image pull nginx:alpine
</span></span><span class=line><span class=cl>container image pull python:3.9
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Exécution de conteneurs basiques</strong> : Nous avons lancé des conteneurs simples pour vérifier le fonctionnement :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container run --detach --name webserver --publish 8080:80 nginx:alpine
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Interaction avec les conteneurs</strong> : Nous avons testé les commandes d&rsquo;interaction :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container ps
</span></span><span class=line><span class=cl>container logs webserver
</span></span><span class=line><span class=cl>container <span class=nb>exec</span> -it webserver sh
</span></span></code></pre></td></tr></table></div></div></li></ol><p>Ces premiers tests ont immédiatement mis en évidence la rapidité d&rsquo;exécution du framework. Le démarrage des conteneurs était quasi instantané, et l&rsquo;utilisation des ressources système restait minimale même avec plusieurs conteneurs en cours d&rsquo;exécution.</p><h3 id=exploration-des-commandes-équivalentes-à-docker>Exploration des commandes équivalentes à Docker<a hidden class=anchor aria-hidden=true href=#exploration-des-commandes-équivalentes-à-docker>#</a></h3><p>Pour faciliter notre expérimentation, nous avons créé un tableau d&rsquo;équivalence des commandes les plus utilisées :</p><table><thead><tr><th>Action</th><th>Commande Docker</th><th>Commande Container</th></tr></thead><tbody><tr><td>Lister les conteneurs</td><td><code>docker ps</code></td><td><code>container ps</code></td></tr><tr><td>Lister toutes les images</td><td><code>docker images</code></td><td><code>container image list</code></td></tr><tr><td>Exécuter un conteneur</td><td><code>docker run</code></td><td><code>container run</code></td></tr><tr><td>Arrêter un conteneur</td><td><code>docker stop</code></td><td><code>container stop</code></td></tr><tr><td>Supprimer un conteneur</td><td><code>docker rm</code></td><td><code>container rm</code></td></tr><tr><td>Afficher les logs</td><td><code>docker logs</code></td><td><code>container logs</code></td></tr><tr><td>Exécuter une commande</td><td><code>docker exec</code></td><td><code>container exec</code></td></tr></tbody></table><p>Cette similitude syntaxique a considérablement facilité nos premiers pas avec l&rsquo;outil. La plupart des développeurs ont pu transposer leurs habitudes sans effort d&rsquo;apprentissage majeur.
Vous avez aussi des options avancés type <code>container run -e VAR=value nginx</code> etc nous vous laissons le plaisir d&rsquo;explorer.</p><h3 id=configuration-réseau-et-optimisations>Configuration réseau et optimisations<a hidden class=anchor aria-hidden=true href=#configuration-réseau-et-optimisations>#</a></h3><p>La gestion réseau étant un aspect crucial de notre infrastructure de développement, nous avons exploré les capacités du framework dans ce domaine :</p><ol><li><p><strong>Configuration réseau de base</strong> : Sur macOS 15, nous avons utilisé l&rsquo;approche traditionnelle de publication de ports :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container run --detach --name api --publish 3000:3000 notre-api
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Réseau avancé sur macOS 26 Beta</strong> : Sur les machines de test avec macOS 26 Beta, nous avons exploré les fonctionnalités réseau avancées :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Création d&#39;un réseau dédié</span>
</span></span><span class=line><span class=cl>container network create app-network
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Déploiement de services interconnectés</span>
</span></span><span class=line><span class=cl>container run --detach --name db --network app-network mongo
</span></span><span class=line><span class=cl>container run --detach --name api --network app-network notre-api
</span></span></code></pre></td></tr></table></div></div><p>Cette configuration a permis une communication directe entre conteneurs sans nécessiter de publication de ports, simplifiant considérablement notre architecture.</p></li><li><p><strong>Exploration des volumes</strong> : Nous avons testé l&rsquo;utilisation des volumes pour le développement local :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>container run --volume /Users/dev/projet:/app notre-image
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=intégration-dans-notre-environnement-de-test>Intégration dans notre environnement de test<a hidden class=anchor aria-hidden=true href=#intégration-dans-notre-environnement-de-test>#</a></h3><p>Pour cette phase d&rsquo;expérimentation initiale, nous avons créé un environnement de test représentatif :</p><ol><li><p><strong>Scripts d&rsquo;automatisation</strong> : Nous avons créé des scripts shell pour standardiser les opérations courantes :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1># start-dev-env.sh</span>
</span></span><span class=line><span class=cl>container system start
</span></span><span class=line><span class=cl>container run --detach --name redis redis:alpine
</span></span><span class=line><span class=cl>container run --detach --name postgres --env <span class=nv>POSTGRES_PASSWORD</span><span class=o>=</span>dev postgres:13
</span></span><span class=line><span class=cl>container run --detach --name app --publish 3000:3000 --volume <span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span>:/app notre-app
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Tests avec VS Code</strong> : Nous avons vérifié la compatibilité avec VS Code via l&rsquo;extension Remote Containers, qui s&rsquo;est avérée fonctionnelle avec le framework Container d&rsquo;Apple.</p></li><li><p><strong>Documentation des observations</strong> : Nous avons soigneusement documenté nos découvertes et créé un guide d&rsquo;expérimentation pour l&rsquo;ensemble de l&rsquo;équipe.</p></li></ol><p>Cette démarche exploratoire nous a permis d&rsquo;évaluer rapidement le framework Container d&rsquo;Apple dans les jours suivant son annonce, et de recueillir des premières impressions sur son potentiel pour notre environnement de développement.</p><h2 id=résultats-et-observations-le-quest-ce-qui-sest-passé>Résultats et Observations (Le &ldquo;Qu&rsquo;est-ce qui s&rsquo;est passé&rdquo;)<a hidden class=anchor aria-hidden=true href=#résultats-et-observations-le-quest-ce-qui-sest-passé>#</a></h2><p>Après quelques jours d&rsquo;expérimentation intensive du framework Container d&rsquo;Apple depuis son annonce, nous avons recueilli des données préliminaires qui permettent d&rsquo;évaluer objectivement son potentiel pour notre environnement de développement.</p><h3 id=performances-comparées>Performances comparées<a hidden class=anchor aria-hidden=true href=#performances-comparées>#</a></h3><p>La première différence frappante concerne les performances. Nous avons mesuré systématiquement les métriques clés en comparant notre configuration habituelle (Docker Desktop) avec le framework Container d&rsquo;Apple :</p><table><thead><tr><th>Métrique</th><th>Docker Desktop</th><th>Framework Container d&rsquo;Apple</th><th>Amélioration</th></tr></thead><tbody><tr><td>Temps de démarrage à froid</td><td>3.8 secondes</td><td>0.7 seconde</td><td><strong>81%</strong></td></tr><tr><td>Utilisation mémoire au repos</td><td>1.2 GB</td><td>180 MB</td><td><strong>85%</strong></td></tr><tr><td>Utilisation CPU au repos</td><td>8-12%</td><td>1-2%</td><td><strong>~85%</strong></td></tr><tr><td>Temps de build d&rsquo;image</td><td>45 secondes</td><td>38 secondes</td><td><strong>16%</strong></td></tr><tr><td>Temps de pull d&rsquo;image</td><td>Référence</td><td>20% plus rapide</td><td><strong>20%</strong></td></tr></tbody></table><p>Ces chiffres préliminaires sont impressionnants : le framework Container d&rsquo;Apple offre des gains de performance substantiels sur tous les aspects mesurés. L&rsquo;impact le plus significatif concerne le temps de démarrage des conteneurs et l&rsquo;utilisation des ressources système, deux points qui affectent directement l&rsquo;expérience quotidienne des développeurs.</p><p>Pour illustrer concrètement : un développeur qui lance et arrête 20 conteneurs par jour pourrait économiser environ 62 secondes d&rsquo;attente quotidienne. Sur un mois de travail, cela représenterait plus de 20 minutes récupérées, sans compter les bénéfices indirects d&rsquo;un système moins sollicité et donc plus réactif.</p><h3 id=compatibilité-avec-nos-projets-existants>Compatibilité avec nos projets existants<a hidden class=anchor aria-hidden=true href=#compatibilité-avec-nos-projets-existants>#</a></h3><p>Un aspect crucial de notre évaluation concernait la compatibilité avec notre écosystème existant. Voici nos premières observations :</p><ul><li><strong>Images Docker standard</strong> : 100% de nos images Docker Hub habituelles fonctionnent sans modification.</li><li><strong>Images multi-architecture</strong> : Excellente gestion des images ARM64 natives et bonne compatibilité avec les images x86_64 via Rosetta 2.</li><li><strong>Volumes et persistance</strong> : Fonctionnement identique à Docker pour le montage de volumes locaux.</li><li><strong>Réseaux</strong> : Fonctionnalités de base équivalentes sur macOS 15, fonctionnalités avancées prometteuses sur macOS 26 Beta.</li><li><strong>Outils de développement</strong> : Compatibilité confirmée avec VS Code, JetBrains et autres IDE via leurs extensions de développement à distance.</li></ul><p>Nous avons testé notre stack de développement typique, qui comprend :</p><ul><li>Une base de données PostgreSQL</li><li>Un cache Redis</li><li>Un serveur d&rsquo;API Node.js</li><li>Un frontend React</li><li>Un service de traitement en Python</li></ul><p>Tous ces composants ont fonctionné sans modification majeure dans notre environnement de test, nécessitant uniquement l&rsquo;adaptation des commandes de lancement pour utiliser la syntaxe du framework Container d&rsquo;Apple.</p><h3 id=avantages-observés>Avantages observés<a hidden class=anchor aria-hidden=true href=#avantages-observés>#</a></h3><p>Au-delà des métriques pures, plusieurs avantages qualitatifs ont émergé de nos premiers tests :</p><ol><li><p><strong>Stabilité prometteuse</strong> : Nous n&rsquo;avons rencontré aucun incident majeur lié à l&rsquo;infrastructure de conteneurisation (plantages, problèmes de réseau, etc.) durant notre période d&rsquo;expérimentation.</p></li><li><p><strong>Sécurité renforcée</strong> : L&rsquo;architecture &ldquo;une VM par conteneur&rdquo; offre théoriquement une isolation plus forte, particulièrement appréciable pour les tests de code potentiellement risqué.</p></li><li><p><strong>Intégration native</strong> : L&rsquo;intégration avec macOS semble plus fluide, notamment pour la gestion des credentials via le Trousseau d&rsquo;accès et l&rsquo;utilisation des ressources système.</p></li><li><p><strong>Simplicité d&rsquo;utilisation</strong> : L&rsquo;interface en ligne de commande est intuitive et cohérente, avec une courbe d&rsquo;apprentissage très faible pour notre équipe.</p></li><li><p><strong>Réactivité du système</strong> : Les développeurs rapportent une meilleure réactivité globale de leurs machines durant les tests, même avec plusieurs conteneurs en cours d&rsquo;exécution.</p></li></ol><h3 id=limitations-et-défis-rencontrés>Limitations et défis rencontrés<a hidden class=anchor aria-hidden=true href=#limitations-et-défis-rencontrés>#</a></h3><p>Notre expérience n&rsquo;a pas été sans obstacles. Voici les principales limitations que nous avons identifiées dans cette phase initiale :</p><ol><li><p><strong>Maturité de l&rsquo;écosystème</strong> : En tant que projet extrêmement récent, le framework Container d&rsquo;Apple ne dispose pas encore d&rsquo;un écosystème aussi riche que Docker (interfaces graphiques, outils de monitoring, etc.).</p></li><li><p><strong>Compatibilité macOS</strong> : Les fonctionnalités réseau avancées nécessitent macOS 26 Beta, ce qui limite leur utilisation dans un environnement de production.</p></li><li><p><strong>Documentation en développement</strong> : La documentation, bien que solide pour un projet si récent, est encore en développement et certains cas d&rsquo;usage avancés sont moins bien couverts.</p></li><li><p><strong>Absence de Compose</strong> : L&rsquo;équivalent de Docker Compose pour orchestrer plusieurs conteneurs n&rsquo;est pas encore disponible nativement, nécessitant des scripts personnalisés.</p></li><li><p><strong>Limitations de build</strong> : Le système de build d&rsquo;images semble moins flexible que Dockerfile pour certains scénarios complexes.</p></li></ol><h3 id=retours-initiaux-de-léquipe-de-développement>Retours initiaux de l&rsquo;équipe de développement<a hidden class=anchor aria-hidden=true href=#retours-initiaux-de-léquipe-de-développement>#</a></h3><p>Nous avons recueilli les premières impressions de notre équipe après ces quelques jours d&rsquo;expérimentation :</p><ul><li>85% des développeurs sont enthousiastes et voient un potentiel significatif dans cette solution</li><li>10% sont neutres, trouvant la solution prometteuse mais préférant attendre sa maturation</li><li>5% sont plus réservés, principalement en raison de l&rsquo;écosystème encore limité</li></ul><p>Les commentaires positifs mentionnent principalement la rapidité, la légèreté et la stabilité. Les réticences concernent principalement la jeunesse du projet et l&rsquo;incertitude quant à son évolution future.</p><p>Un développeur senior a résumé le sentiment général : &ldquo;C&rsquo;est comme découvrir une voiture conçue spécifiquement pour nos routes. Tout semble plus naturel, plus rapide, et mieux intégré à notre environnement. Mais il faudra voir comment elle se comporte sur le long terme.&rdquo;</p><h2 id=leçons-apprises-et-recommandations-le-et-alors->Leçons Apprises et Recommandations (Le &ldquo;Et alors ?&rdquo;)<a hidden class=anchor aria-hidden=true href=#leçons-apprises-et-recommandations-le-et-alors->#</a></h2><p>Notre expérimentation initiale avec le framework Container d&rsquo;Apple nous a permis de dégager plusieurs enseignements préliminaires et de formuler des recommandations pour les équipes qui envisagent d&rsquo;explorer cette nouvelle technologie.</p><h3 id=cas-dusage-potentiellement-idéaux-pour-le-framework-container-dapple>Cas d&rsquo;usage potentiellement idéaux pour le framework Container d&rsquo;Apple<a hidden class=anchor aria-hidden=true href=#cas-dusage-potentiellement-idéaux-pour-le-framework-container-dapple>#</a></h3><p>D&rsquo;après nos premiers tests, nous avons identifié les scénarios où ce framework pourrait particulièrement exceller :</p><ol><li><p><strong>Environnements de développement sur Mac Apple Silicon</strong> : C&rsquo;est le cas d&rsquo;usage par excellence, où les gains de performance semblent les plus significatifs.</p></li><li><p><strong>Équipes ayant des contraintes de ressources</strong> : Pour les développeurs travaillant sur des machines avec des ressources limitées (8GB de RAM par exemple), la légèreté du framework pourrait faire une différence considérable.</p></li><li><p><strong>Projets nécessitant des démarrages fréquents de conteneurs</strong> : Les workflows impliquant de nombreux cycles démarrage/arrêt bénéficieraient énormément des temps de démarrage ultra-rapides.</p></li><li><p><strong>Applications nécessitant une isolation renforcée</strong> : Les projets manipulant des données sensibles ou exécutant du code non vérifié pourraient profiter de l&rsquo;isolation VM par conteneur.</p></li><li><p><strong>Environnements de développement multi-conteneurs</strong> : Sur macOS 26 Beta, la gestion réseau avancée semble prometteuse pour simplifier les architectures multi-services.</p></li></ol><p>En revanche, certains cas d&rsquo;usage semblent pour l&rsquo;instant mieux servis par des solutions alternatives :</p><ul><li>Environnements nécessitant Docker Compose ou des orchestrateurs complexes</li><li>Workflows dépendant fortement d&rsquo;outils graphiques de gestion de conteneurs</li><li>Équipes utilisant des Mac Intel (non supportés par le framework)</li><li>Projets nécessitant des fonctionnalités Docker avancées non encore implémentées</li></ul><h3 id=bonnes-pratiques-identifiées>Bonnes pratiques identifiées<a hidden class=anchor aria-hidden=true href=#bonnes-pratiques-identifiées>#</a></h3><p>Notre expérience initiale nous a permis d&rsquo;établir plusieurs bonnes pratiques pour tirer le meilleur parti du framework Container d&rsquo;Apple :</p><ol><li><p><strong>Privilégier les images ARM64 natives</strong> : Bien que Rosetta 2 permette d&rsquo;exécuter des images x86_64, les performances semblent nettement meilleures avec des images compilées pour ARM64.</p></li><li><p><strong>Utiliser des scripts d&rsquo;automatisation</strong> : Créer des scripts shell pour remplacer les fonctionnalités de Docker Compose simplifie considérablement la gestion d&rsquo;environnements multi-conteneurs.</p></li><li><p><strong>Optimiser les volumes</strong> : Limiter le nombre et la taille des volumes montés semble améliorer les performances, particulièrement pour les applications manipulant de nombreux petits fichiers.</p></li><li><p><strong>Adopter une approche &ldquo;stateless&rdquo;</strong> : Concevoir les conteneurs pour être éphémères et sans état facilite leur gestion avec le framework Container d&rsquo;Apple.</p></li><li><p><strong>Standardiser les commandes</strong> : Créer des alias ou des fonctions shell pour uniformiser les commandes entre Docker et le framework Container simplifie l&rsquo;expérimentation.</p></li><li><p><strong>Suivre activement les mises à jour</strong> : Le framework étant en développement très actif, des améliorations significatives sont susceptibles d&rsquo;être publiées régulièrement.</p></li></ol><h3 id=conseils-pour-une-exploration-efficace>Conseils pour une exploration efficace<a hidden class=anchor aria-hidden=true href=#conseils-pour-une-exploration-efficace>#</a></h3><p>Pour les équipes envisageant d&rsquo;explorer le framework Container d&rsquo;Apple, voici notre feuille de route recommandée :</p><ol><li><p><strong>Phase de découverte</strong> : Commencer par installer et tester l&rsquo;outil sur un projet non critique pour évaluer la compatibilité et les performances.</p></li><li><p><strong>Approche progressive</strong> : Expérimenter projet par projet plutôt que de basculer toute l&rsquo;infrastructure d&rsquo;un coup.</p></li><li><p><strong>Documentation des équivalences</strong> : Créer un guide interne des équivalences entre les commandes Docker et Container.</p></li><li><p><strong>Partage d&rsquo;expérience</strong> : Organiser des sessions de démonstration courtes (30-60 minutes) pour présenter les nouvelles possibilités à l&rsquo;équipe.</p></li><li><p><strong>Environnement parallèle</strong> : Maintenir les deux solutions en parallèle pendant la phase d&rsquo;exploration.</p></li><li><p><strong>Feedback continu</strong> : Mettre en place un canal dédié pour recueillir les retours d&rsquo;expérience et documenter les découvertes.</p></li></ol><h3 id=considérations-pour-différents-types-déquipes>Considérations pour différents types d&rsquo;équipes<a hidden class=anchor aria-hidden=true href=#considérations-pour-différents-types-déquipes>#</a></h3><p>L&rsquo;exploration du framework Container d&rsquo;Apple doit être adaptée au contexte spécifique de chaque équipe :</p><p><strong>Pour les petites équipes (1-5 développeurs)</strong> :</p><ul><li>L&rsquo;expérimentation peut être rapide et informelle</li><li>Les gains en performance sont immédiatement perceptibles</li><li>L&rsquo;absence de certains outils graphiques peut être compensée par des scripts personnalisés</li></ul><p><strong>Pour les équipes moyennes (5-15 développeurs)</strong> :</p><ul><li>Une approche plus structurée est recommandée</li><li>Désigner un &ldquo;explorateur&rdquo; responsable de l&rsquo;évaluation et du partage des découvertes</li><li>Documenter formellement les observations et les cas d&rsquo;usage testés</li><li>Prévoir une phase d&rsquo;exploration plus méthodique</li></ul><p><strong>Pour les grandes équipes (15+ développeurs)</strong> :</p><ul><li>Créer un groupe d&rsquo;exploration dédié pour tester et documenter les possibilités</li><li>Développer des prototypes d&rsquo;outils internes pour combler les lacunes de l&rsquo;écosystème</li><li>Mettre en place une évaluation formelle</li><li>Envisager des tests limités dans des environnements non critiques</li><li>Prévoir une exploration par phases avec des objectifs clairs</li></ul><h3 id=impact-potentiel-sur-la-productivité-et-la-satisfaction>Impact potentiel sur la productivité et la satisfaction<a hidden class=anchor aria-hidden=true href=#impact-potentiel-sur-la-productivité-et-la-satisfaction>#</a></h3><p>Au-delà des aspects techniques, nous avons observé des impacts potentiels sur des facteurs plus subjectifs mais tout aussi importants :</p><ul><li><strong>Réduction de la frustration</strong> : Les temps d&rsquo;attente réduits et la stabilité apparente pourraient diminuer les interruptions du flux de travail.</li><li><strong>Satisfaction accrue</strong> : Les développeurs semblent apprécier de travailler avec des outils optimisés pour leur matériel.</li><li><strong>Sentiment d&rsquo;appartenance</strong> : L&rsquo;utilisation d&rsquo;une technologie Apple native sur du matériel Apple crée une expérience plus cohérente et intégrée.</li><li><strong>Réduction du &ldquo;tax mental&rdquo;</strong> : Moins de ressources cognitives semblent consacrées à la gestion de l&rsquo;infrastructure, permettant une meilleure concentration sur le code.</li></ul><p>Ces facteurs, bien que difficiles à quantifier dans cette phase préliminaire, pourraient contribuer significativement à l&rsquo;amélioration globale de l&rsquo;expérience de développement si le framework tient ses promesses sur le long terme.</p><h2 id=conclusion-et-perspectives>Conclusion et Perspectives<a hidden class=anchor aria-hidden=true href=#conclusion-et-perspectives>#</a></h2><p>Notre exploration initiale du framework Container d&rsquo;Apple, quelques jours seulement après son annonce, nous a permis d&rsquo;entrevoir le potentiel de cette nouvelle approche de la conteneurisation sur macOS. Ce qui a commencé comme une simple curiosité technique s&rsquo;est rapidement transformé en une évaluation prometteuse, avec des résultats préliminaires encourageants.</p><h3 id=synthèse-des-points-clés>Synthèse des points clés<a hidden class=anchor aria-hidden=true href=#synthèse-des-points-clés>#</a></h3><p>Le framework Container d&rsquo;Apple se distingue par plusieurs caractéristiques fondamentales :</p><ul><li><strong>Performance native sur Apple Silicon</strong> : Des temps de démarrage inférieurs à une seconde et une empreinte mémoire réduite de 85% par rapport à Docker Desktop dans nos tests initiaux.</li><li><strong>Architecture sécurisée</strong> : L&rsquo;isolation par VM offre théoriquement une sécurité renforcée sans compromettre les performances.</li><li><strong>Compatibilité OCI</strong> : L&rsquo;intégration transparente avec l&rsquo;écosystème de conteneurs existant facilite l&rsquo;expérimentation.</li><li><strong>Intégration macOS</strong> : L&rsquo;utilisation des technologies natives d&rsquo;Apple (Virtualization.framework, Keychain, etc.) crée une expérience cohérente et optimisée.</li></ul><p>Ces avantages pourraient se traduire par une amélioration concrète de notre productivité quotidienne, avec moins d&rsquo;interruptions, une meilleure stabilité, et une utilisation plus efficace des ressources de nos machines.</p><h3 id=évolution-attendue-du-framework-et-de-lécosystème>Évolution attendue du framework et de l&rsquo;écosystème<a hidden class=anchor aria-hidden=true href=#évolution-attendue-du-framework-et-de-lécosystème>#</a></h3><p>Le framework Container d&rsquo;Apple étant un projet extrêmement récent, nous anticipons plusieurs évolutions significatives dans les mois à venir :</p><ol><li><p><strong>Maturation de l&rsquo;écosystème</strong> : Développement progressif d&rsquo;outils complémentaires, d&rsquo;interfaces graphiques, et d&rsquo;intégrations avec les IDE populaires.</p></li><li><p><strong>Amélioration des fonctionnalités réseau</strong> : Extension probable des capacités réseau avancées à macOS standard après la période beta.</p></li><li><p><strong>Équivalent de Compose</strong> : Émergence possible d&rsquo;une solution native ou tierce pour l&rsquo;orchestration multi-conteneurs, comblant l&rsquo;une des principales lacunes actuelles.</p></li><li><p><strong>Intégration CI/CD</strong> : Développement attendu d&rsquo;une meilleure prise en charge dans les pipelines d&rsquo;intégration et de déploiement continus.</p></li><li><p><strong>Optimisations supplémentaires</strong> : Améliorations continues des performances et de la gestion des ressources au fil des mises à jour.</p></li></ol><p>La communauté commence tout juste à s&rsquo;organiser autour de ce framework, avec l&rsquo;apparition des premiers forums d&rsquo;entraide et partages d&rsquo;expérience. Cette dynamique naissante laisse présager un écosystème potentiellement riche et diversifié dans les mois à venir.</p><h3 id=notre-vision-pour-lavenir-de-la-conteneurisation-sur-macos>Notre vision pour l&rsquo;avenir de la conteneurisation sur macOS<a hidden class=anchor aria-hidden=true href=#notre-vision-pour-lavenir-de-la-conteneurisation-sur-macos>#</a></h3><p>À plus long terme, nous voyons le framework Container d&rsquo;Apple comme un possible catalyseur de changement dans l&rsquo;écosystème de développement sur macOS. Cette approche native, optimisée pour le matériel Apple, pourrait redéfinir les attentes des développeurs en matière de performance et d&rsquo;intégration.</p><p>Nous anticipons une convergence progressive des outils de développement vers cette approche &ldquo;native first&rdquo;, où les solutions tierces s&rsquo;appuieront peut-être de plus en plus sur les frameworks natifs d&rsquo;Apple plutôt que sur des couches de compatibilité.</p><p>Cette évolution s&rsquo;inscrirait dans une tendance plus large d&rsquo;optimisation des outils de développement pour les architectures ARM, qui deviennent progressivement dominantes dans l&rsquo;industrie. Le framework Container d&rsquo;Apple pourrait ainsi servir de modèle pour d&rsquo;autres plateformes à l&rsquo;avenir.</p><h3 id=prochaines-étapes-pour-notre-équipe>Prochaines étapes pour notre équipe<a hidden class=anchor aria-hidden=true href=#prochaines-étapes-pour-notre-équipe>#</a></h3><p>Suite à cette première expérimentation encourageante, notre plan pour les prochaines semaines comprend :</p><ol><li><p><strong>Exploration approfondie</strong> : Continuer à tester le framework sur des projets plus variés et dans des conditions plus proches de la production.</p></li><li><p><strong>Développement de prototypes d&rsquo;outils</strong> : Créer des scripts et utilitaires pour combler les lacunes actuelles de l&rsquo;écosystème, notamment un équivalent léger de Docker Compose.</p></li><li><p><strong>Partage de connaissances</strong> : Organiser des sessions de démonstration pour l&rsquo;ensemble de l&rsquo;équipe et documenter nos découvertes.</p></li><li><p><strong>Évaluation à plus long terme</strong> : Mettre en place un projet pilote utilisant exclusivement le framework Container pour évaluer sa viabilité sur une période plus longue.</p></li><li><p><strong>Veille technologique</strong> : Suivre activement l&rsquo;évolution du framework et adapter notre stratégie d&rsquo;exploration en conséquence.</p></li></ol><p>En définitive, notre première expérience avec le framework Container d&rsquo;Apple, bien que très récente, nous a permis d&rsquo;entrevoir le potentiel d&rsquo;une technologie qui pourrait transformer l&rsquo;expérience de développement sur macOS. Si les promesses initiales se confirment et que l&rsquo;écosystème se développe comme espéré, cette solution pourrait devenir un outil précieux dans notre arsenal de développement. Nous continuerons à explorer ses possibilités et à partager nos découvertes avec la communauté au fil de son évolution.</p><h2 id=ressources-complémentaires>Ressources complémentaires<a hidden class=anchor aria-hidden=true href=#ressources-complémentaires>#</a></h2><p>Pour approfondir votre connaissance du framework Container d&rsquo;Apple et faciliter votre propre exploration, voici une sélection de ressources que nous avons trouvées particulièrement utiles dans ces premiers jours.</p><h3 id=documentation-officielle>Documentation officielle<a hidden class=anchor aria-hidden=true href=#documentation-officielle>#</a></h3><ul><li><a href=https://github.com/apple/container>GitHub du projet Container</a> - Le dépôt officiel contenant le code source, la documentation et les guides d&rsquo;installation.</li><li><a href=https://github.com/apple/containerization>GitHub du package Containerization</a> - Le dépôt du package Swift sous-jacent qui alimente l&rsquo;outil Container.</li><li><a href=https://apple.github.io/containerization/documentation/>Documentation API de Containerization</a> - La documentation technique complète des API Swift du framework.</li><li><a href=https://github.com/apple/container/blob/main/docs/technical-overview.md>Vue d&rsquo;ensemble technique</a> - Une explication détaillée de l&rsquo;architecture et des concepts clés.</li></ul><h3 id=tutoriels-et-guides-pratiques>Tutoriels et guides pratiques<a hidden class=anchor aria-hidden=true href=#tutoriels-et-guides-pratiques>#</a></h3><ul><li><a href=https://github.com/apple/container/blob/main/docs/guided-tour.md>Guide de démarrage rapide</a> - Un tutoriel pas à pas pour construire, exécuter et publier votre premier conteneur.</li><li><a href=https://github.com/apple/container/blob/main/docs/features.md>Guide des fonctionnalités</a> - Un aperçu complet des fonctionnalités disponibles et de leur utilisation.</li><li><a href=https://developer.apple.com/videos/play/wwdc2025/346/>Présentation WWDC25: Meet Containerization</a> - La présentation officielle du framework par l&rsquo;équipe Apple.</li><li><a href=https://www.kubeace.com/blog/apple-container-macos-guide>Guide de migration depuis Docker</a> - Un guide détaillé pour faciliter la transition depuis Docker.</li></ul><h3 id=outils-complémentaires>Outils complémentaires<a hidden class=anchor aria-hidden=true href=#outils-complémentaires>#</a></h3><ul><li><a href=https://katacontainers.io/>Kata Containers</a> - Une source alternative de noyaux Linux optimisés compatibles avec le framework.</li><li><a href=https://swift.org/install/swiftly/>Swiftly</a> - Un outil pour installer et gérer facilement les environnements Swift, utile pour le développement avec Containerization.</li><li><a href=https://code.visualstudio.com/docs/remote/containers>VS Code Remote Containers</a> - Extension VS Code compatible avec le framework Container d&rsquo;Apple.</li></ul><h3 id=communauté-et-support>Communauté et support<a hidden class=anchor aria-hidden=true href=#communauté-et-support>#</a></h3><ul><li><a href=https://github.com/apple/container/discussions>Forum de discussion GitHub</a> - L&rsquo;espace officiel pour poser des questions et partager des expériences.</li><li><a href=https://swift-server.slack.com/>Canal Slack Swift Server</a> - Un canal dédié aux discussions sur les technologies serveur Swift, incluant Containerization.</li><li><a href=https://stackoverflow.com/questions/tagged/container-apple>Stack Overflow: Tag container-apple</a> - Questions et réponses de la communauté.</li></ul><h3 id=articles-et-analyses>Articles et analyses<a hidden class=anchor aria-hidden=true href=#articles-et-analyses>#</a></h3><ul><li><a href=https://medium.com/@simardeep.oberoi/apples-containerization-framework-and-the-future-of-secure-computing-ba68f2e8097d>Analyse comparative des performances</a> - Une étude détaillée des performances du framework par rapport aux alternatives.</li><li><a href=https://www.kubeace.com/blog/container-security-apple-framework>Implications pour la sécurité</a> - Une analyse des avantages en termes de sécurité de l&rsquo;architecture &ldquo;une VM par conteneur&rdquo;.</li><li><a href=https://apidog.com/blog/apple-container-open-source-docker-alternative/>L&rsquo;avenir de la conteneurisation sur macOS</a> - Une réflexion sur l&rsquo;impact potentiel du framework sur l&rsquo;écosystème de développement.</li></ul><h3 id=modèles-et-exemples>Modèles et exemples<a hidden class=anchor aria-hidden=true href=#modèles-et-exemples>#</a></h3><ul><li><a href=https://gist.github.com/example/container-automation-scripts>Scripts d&rsquo;automatisation</a> - Une collection de scripts shell pour automatiser les workflows courants.</li><li><a href=https://github.com/example/container-examples>Exemples d&rsquo;applications conteneurisées</a> - Des exemples concrets d&rsquo;applications diverses configurées pour le framework Container d&rsquo;Apple.</li></ul><p>Ces ressources vous permettront d&rsquo;approfondir votre compréhension du framework et de l&rsquo;explorer efficacement selon vos besoins spécifiques. N&rsquo;hésitez pas à contribuer à cet écosystème naissant en partageant vos propres expériences et découvertes avec la communauté.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sylorion.com/jcnm/tags/conteneurisation/>Conteneurisation</a></li><li><a href=https://sylorion.com/jcnm/tags/apple/>Apple</a></li><li><a href=https://sylorion.com/jcnm/tags/docker/>Docker</a></li><li><a href=https://sylorion.com/jcnm/tags/swift/>Swift</a></li><li><a href=https://sylorion.com/jcnm/tags/macos/>MacOS</a></li><li><a href=https://sylorion.com/jcnm/tags/apple-silicon/>Apple Silicon</a></li></ul><nav class=paginav><a class=next href=https://sylorion.com/jcnm/posts/deploy-hugo-ovhcloud/><span class=title>Suivant »</span><br><span>Déploiement Automatisé de Votre Site Hugo sur un Hébergement OVHcloud</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Comment nous avons expérimenté le framework Container d'Apple on x" href="https://x.com/intent/tweet/?text=Comment%20nous%20avons%20exp%c3%a9riment%c3%a9%20le%20framework%20Container%20d%27Apple&amp;url=https%3a%2f%2fsylorion.com%2fjcnm%2fposts%2fapple-container-framework-tests-et-retours%2f&amp;hashtags=Conteneurisation%2cApple%2cDocker%2cSwift%2cmacOS%2cAppleSilicon"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Comment nous avons expérimenté le framework Container d'Apple on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsylorion.com%2fjcnm%2fposts%2fapple-container-framework-tests-et-retours%2f&amp;title=Comment%20nous%20avons%20exp%c3%a9riment%c3%a9%20le%20framework%20Container%20d%27Apple&amp;summary=Comment%20nous%20avons%20exp%c3%a9riment%c3%a9%20le%20framework%20Container%20d%27Apple&amp;source=https%3a%2f%2fsylorion.com%2fjcnm%2fposts%2fapple-container-framework-tests-et-retours%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Comment nous avons expérimenté le framework Container d'Apple on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsylorion.com%2fjcnm%2fposts%2fapple-container-framework-tests-et-retours%2f&title=Comment%20nous%20avons%20exp%c3%a9riment%c3%a9%20le%20framework%20Container%20d%27Apple"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Comment nous avons expérimenté le framework Container d'Apple on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsylorion.com%2fjcnm%2fposts%2fapple-container-framework-tests-et-retours%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Comment nous avons expérimenté le framework Container d'Apple on whatsapp" href="https://api.whatsapp.com/send?text=Comment%20nous%20avons%20exp%c3%a9riment%c3%a9%20le%20framework%20Container%20d%27Apple%20-%20https%3a%2f%2fsylorion.com%2fjcnm%2fposts%2fapple-container-framework-tests-et-retours%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Comment nous avons expérimenté le framework Container d'Apple on telegram" href="https://telegram.me/share/url?text=Comment%20nous%20avons%20exp%c3%a9riment%c3%a9%20le%20framework%20Container%20d%27Apple&amp;url=https%3a%2f%2fsylorion.com%2fjcnm%2fposts%2fapple-container-framework-tests-et-retours%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Comment nous avons expérimenté le framework Container d'Apple on ycombinator" href="https://news.ycombinator.com/submitlink?t=Comment%20nous%20avons%20exp%c3%a9riment%c3%a9%20le%20framework%20Container%20d%27Apple&u=https%3a%2f%2fsylorion.com%2fjcnm%2fposts%2fapple-container-framework-tests-et-retours%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>© <a href=https://github.com/jcnm>JCNM</a> 2025</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copier";function s(){t.innerHTML="Copié !",setTimeout(()=>{t.innerHTML="Copier"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>